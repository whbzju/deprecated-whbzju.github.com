<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[知行录]]></title>
  <link href="http://whbzju.github.com/atom.xml" rel="self"/>
  <link href="http://whbzju.github.com/"/>
  <updated>2015-04-18T20:50:51+08:00</updated>
  <id>http://whbzju.github.com/</id>
  <author>
    <name><![CDATA[阿波]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[微店引发的互联网模式思考]]></title>
    <link href="http://whbzju.github.com/blog/2015/04/18/think-about-weidian-bussiness/"/>
    <updated>2015-04-18T20:48:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2015/04/18/think-about-weidian-bussiness</id>
    <content type="html"><![CDATA[<p>现有爆发的互联网模式，体现在将原先只有一小部分人能享受到的服务面向大众，从而实现对现有产业的改造。比如小米，原先苹果三星的价格导致大部分用户无法享受他们的产品。小米提供了一个相对优质的产品，牺牲了不少品质，比如外观、做工，但成功将价格定在大众可接受的区间，从而实现了爆发式的增长。这种例子，传统行业也有过很多例子，比如优衣库、Zara，将上流用户的衣服，通过降低一定的质量和设计，完成价格革命，让普通用户享受到时尚，从而实现服装行业的革命。相同的例子还有福特，将汽车面向普通大众。这些例子说明一个，在品质和价格间做好balance，将优质的服务面向大众，具有极大的潜力，同时也说明了一个行业趋向成熟。</p>

<p>回过头来仔细想下，为何苹果三星不直接面向大众提供服务。这里面除了品牌定位，还涉及到一个行业的发展。在行业发展初期，各种成本都是高昂的，所以只能面向一些高端用户。高端用户的定义可以是：对价格不敏感，但对品质有较高的要求。够用和追求品质是区分普通商品和奢侈品的重要区别，俗话说一分钱一分货，十分钱两分货。奢侈品对于人类有重要的意义，在这些no functional的地方持续的投入，恰是文明的来源。拉回来看前面的例子，若要将高端用户使用的服务面向大众，其品质必然会有所下降，但会进入一个处于可接受的范围，接着极力的压榨价格区间，进入市场后照成破坏性的增长，一家独霸。这里小米做到了，淘宝也做到了一半。</p>

<p>来看今天的主题—微店，即微商。上面说到淘宝做到了一半，即对传统的零售商业模式的冲击并没有完成一家独霸，彻底改造。其原因在于，其商品价格下来后，优质的服务不能保证，即没有进入一个合理的区间。这里面的问题比较复杂，刨去假货不说，很多时候商品质量不好，真就是商家无法提供优质的服务。因为这些优质的服务被传统大佬们垄断着。淘宝可以抹除店面、分销的成本，但无法解决生产的问题，当这些大佬进入电商后，很快就被击垮。那为什么要提到微商，因为中国作为一个世界大工厂已经很多年，其生产能力在不断的提升，但缺少产品设计和分销渠道。而微商类似于，拥有这些资源的个人，不愿意被传统的渠道垄断，但有无法承担建立品牌的费用，借力与人与人直接的信任传播来实现分销。</p>

<p>这里重点讲下品牌，淘宝最大的问题还是在于流量越来越贵，小商户直接就出局了，没有办法顺利的进入成长期。而传统的大佬在建立品牌投入的巨大成本，需要靠一定的利润空间收回。所以，如果想打赢这场仗，必须抹除建立品牌的成本，而这也是微商可能能够提供的。天下没有免费得晚餐，如果不是某个环节的效率提高了导致价格的下降，这种模式是不可持续的。这也是为什么目前微商中的代购、面膜之类的东西不能长远的原因。从这点来看当前几个比较热的互联网公司，能得到一定的启示。拨开热闹的表象，观察其是否能照成流程或生产力的提高。比如小米最近的装修，就是一个极好的商业切入点，非常值得资本进入烧钱。同样的还有快的和滴滴。</p>

<p>最后，互联网模式有个重要的特点，即scalable—即高度可复制性，这点下次再讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kaggle入门总结]]></title>
    <link href="http://whbzju.github.com/blog/2015/04/18/kaggle-bike/"/>
    <updated>2015-04-18T20:38:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2015/04/18/kaggle-bike</id>
    <content type="html"><![CDATA[<p>在知乎上看过一个答案，大意是有个地方叫kaggle，推荐搞机器学习的同学多上去撸一撸，实践出真知。同时还建议先把101系列的题目撸完，再选个感兴趣的比赛做。该答案详情见参考文献。</p>

<h2 id="section">工具</h2>
<p>有工程背景的同学，建议python，拥有不输给R的生态。主要用到以下工具：</p>

<pre><code>ipython notebook + pandas + sklearn
</code></pre>

<p>在面对特别大的数据集，使用了公司的spark。</p>

<ul>
  <li>ipython notebook，神器，请参考我的另一篇blog <a href="http://www.wujiame.com/blog/2014/11/23/ipython-notebook-bring-to-me/">Ipython Notebook对机器学习工程师的价值</a></li>
  <li>pandas: 从工程过来的同学，首先请放弃循环之类的代码实现方式，拥抱dataframe。</li>
  <li>sklearn：在github上非常活跃的项目，请多读官方文档。</li>
  <li>spark：一般kaggle上比赛的数据量级是没有必要用它，但是最近有个比赛train的数据上百g了，所以试了下它。</li>
</ul>

<h2 id="section-1">比赛选择</h2>

<p>首先，请从101系列中选几个做做，该系列一般有详细的教程，熟悉kaggle。接着选几个正在进行的比赛练手。一开始别贪心，注意下数据集的大小，当数据集大于几个g后，工程相关的工作会增加很多，同时对单机的性能有一定的要求，不利于初学者。但是，数据量大更符合真实的情况，比如做过一个ctr预估的比赛，无论是特征工程和模型训练都要更小心谨慎，每次试错的成本很高，随便训练一个模型都需要3-4小时，相应的这个比赛让我意思到sample的重要性，以及一个非常重要的特征处理方法<a href="http://www.wujiame.com/blog/2015/02/10/feature-hashing/">featrue hashing</a>.</p>

<p>本文将重点总结我在做自行车出租数量预测这个比赛的情况。该比赛介绍如下：</p>

<blockquote>
  <p>You are provided hourly rental data spanning two years. For this competition, the training set is comprised of the first 19 days of each month, while the test set is the 20th to the end of the month. You must predict the total count of bikes rented during each hour covered by the test set, using only information available prior to the rental period.</p>
</blockquote>

<p>该比赛的好处是符合kaggle的特点。</p>

<ol>
  <li>feature engineering是第一要素。</li>
  <li>ensemble大法好。bagging、averaging一起上，比如到最后我喜欢用random forest + gbdt组合再搞一把，总能给我惊喜。</li>
  <li>时刻小心过拟合。</li>
</ol>

<h2 id="section-2">特征工程</h2>

<ol>
  <li>异常值处理，nan，outlier等。hist和box是两个常用的图形工具。</li>
  <li>数据分布倾斜。 log变化、正负样本重新抽样等。</li>
  <li>特征交叉组合 </li>
  <li>pca或random forest的特征重要性选择。</li>
  <li>特征之间的相关系数。</li>
  <li>特征onehotencoding</li>
</ol>

<h2 id="section-3">模型选择</h2>

<ol>
  <li>Logistic regression</li>
  <li>Random Forest </li>
  <li>gbdt和gbrt</li>
  <li>Factorization Machines</li>
</ol>

<p>LR对特征要求更高，比如很多categorical的特征要作binary编码。我个人倾斜于RF和gbdt，都是属于ensemble思想下的算法。具体RF算法可以参考以前写的一篇blog：<a href="http://www.wujiame.com/blog/2015/02/16/random-forest/">random forest</a></p>

<p>Factorization Machines这个算法好多人用它做ctr预估，后续可以研究下。</p>

<h2 id="section-4">代码分享</h2>

<p>具体代码实现请看我的notebook：
<a href="http://nbviewer.ipython.org/gist/whbzju/ff06fce9fd738dcf8096">kaggle上的自行车出租数量预测</a></p>

<h2 id="section-5">参考文献</h2>

<p>[1] 知乎答案<a href="http://www.zhihu.com/question/23987009">Kaggle如何入门</a></p>

<p>[2] 知乎答案<a href="http://www.zhihu.com/question/24533374">参加kaggle竞赛是怎样一种体验？</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[random forest]]></title>
    <link href="http://whbzju.github.com/blog/2015/02/16/random-forest/"/>
    <updated>2015-02-16T15:09:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2015/02/16/random-forest</id>
    <content type="html"><![CDATA[<h2 id="section">概述</h2>

<h3 id="section-1">知识背景要求</h3>

<p>本文要求读者对机器学习中的一些基本概念有一定了解，比如特征，交叉验证，generation等概念。随机森林基于决策树模型，读者事先最好对决策树有一定的了解，若完全不了解，请将文中的tree抽象成能告诉你对错的一个black box，则不会影响理解。</p>

<h3 id="section-2">目录</h3>

<ol>
  <li>基本思想</li>
  <li>理论保证</li>
  <li>实践中常用的特性</li>
  <li>实践效果验证</li>
  <li>需要重点注意的</li>
  <li>参考</li>
</ol>

<h2 id="section-3">基本思想</h2>

<h3 id="ensemble-method">Ensemble method</h3>

<p>ensemble是当前主流机器学习领域一个非常流行的概念。引用sklearn的文档：</p>

<blockquote>
  <p>The goal of ensemble methods is to combine the predictions of several base estimators built with a given learning algorithm in order to improve generalizability / robustness over a single estimator.</p>
</blockquote>

<p>其又分为两大类：averaging和boosting，分别以Random Forest和AdaBoost算法为代表。</p>

<h3 id="random-forest">Random Forest</h3>

<p>引用wiki的定义：</p>

<blockquote>
  <p>Random forests are an ensemble learning method for classification, regression and other tasks, that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees. </p>
</blockquote>

<p>直白来讲，随机森林就是将一堆决策树聚在一起，形成一个森林，让每个决策树对测试目标投票，最后对结果求平均，得到最终结果。举个例子：今天你要预测中国队能不能进入世界杯，你找了一百个朋友，让他们每个人给个预测，最后对所有人的预测结果求平均，得到最后中国队能不能出线的结论。直观来理解，这个模型最终结果受到两个因素影响，这一百个朋友中每个人对足球的了解程度和这些人之间的差异程度。</p>

<p>换个正式点的描述：首先，我们假设你了解如果构造一个决策树，随机森林构造了很多个决策树，对于一个数据集N，每次随机抽取n个数据和m个特征，构造一个完全生长的树（不用剪枝），将数据放回重复上述过程，直到生成M棵树。其中有放回的抽样称为bootstrap，是非常重要的概念，下文中让随机森林不用交叉验证的out-of-bag理论基于此。在最初的那篇论文，提到该模型的error受两个因素影响：</p>

<pre><code>* 每个树之间的correction。correction增加，error增加。
* 单独一颗树的strength（不知道怎么翻译，能力？）。strength增加，error下降。
</code></pre>

<p>随机选取m个特征是个关键的步骤，假设总特征有M个，m越小，correction和strength越小。m越大，correction和strength越大。一个合理的m很重要。</p>

<h2 id="section-4">理论保证</h2>

<p>写公式好累，大家去看参考文献吧。</p>

<h2 id="section-5">常用特性</h2>

<ul>
  <li>oob </li>
  <li>feature importance</li>
  <li>聚类</li>
</ul>

<h3 id="the-out-of-bag-oob-error-estimate">The out-of-bag (oob) error estimate</h3>

<p>前面提到过boostrap，这个抽样机制从理论上决定了每次抽样有近三分之一的数据不会被抽到，即可以直接拿来做为测试集，使random forest免去cross validation的过程，节省了时间，称为oob。</p>

<h3 id="feature-importance">feature importance</h3>

<p>random forest是个black box，feature importance特性有助于模型的可解释性。简单考虑下，就算在解释性很强的决策树模型中，如果树过于庞大，人类也很难解释它做出的结果。随机森林通常会有上百棵树组成，更加难以解释。好在我们可以找到那些特征是更加重要的，从而辅助我们解释模型。更加重要的是可以剔除一些不重要的特征，降低杂讯。比起pca降维后的结果，更具有人类的可理解性。</p>

<p>feature importance有好几种方案实现，最常用的是基于一个思想：如果该特征非常的重要，那么稍微改变一点它的值，就会对模型造成很大的影响。再偷个懒，自己造数据太麻烦，可以直接在数据集对该维度的特征数据进行打乱，重新训练测试，打乱前的准确率减去打乱后的准确率就是该特征的重要度。该方法又叫permute。</p>

<h3 id="unsupervised-learning-">Unsupervised learning 聚类</h3>

<p>有点出乎意料，原来随机森林还可以做聚类。总所周知，聚类算法的关键是相识度计算，而随机森林能很好的做相识度计算。首先让我们了解下Proximities：</p>

<blockquote>
  <p>The proximities originally formed a NxN matrix. After a tree is grown, put all of the data, both training and oob, down the tree. If cases k and n are in the same terminal node increase their proximity by one. At the end, normalize the proximities by dividing by the number of trees.</p>
</blockquote>

<p>大致的意思是说，在随机森林模型生成时，统计case k和n在不在同一个叶子节点中，在就加1，最后在安装树的个数归一化。得到case之间的相似度。</p>

<h2 id="section-6">实践效果验证</h2>

<p>在工作中，随机森林被我用来做的最多的事情还是feature importance，验证自己的特征工程效果。另外，由于它的鲁棒性特别好，模型效果在各大模型中排中等，而且对数据预处理要求低，我经常会优先选择用它跑个benchmark。</p>

<p>业余时间还会玩玩kaggle比赛，它就用的比较多，其实gbdt应该更适合比赛，但我个人还是偏好RF。下面放个kaggle的比赛总结，关于如何用它：<a href="https://www.kaggle.com/c/titanic-gettingStarted/details/getting-started-with-random-forests">Getting Started with Random Forests: Titanic Competition</a></p>

<h2 id="section-7">需要重点注意的</h2>

<p>以sklearn的RandomForestClassifier为例，有几个参数需要调下。</p>

<ol>
  <li>n_estimators。决定模型有几颗树，我在做Click-Through Rate Prediction比赛时，将它从default 10改到100，模型效果提升了很多。</li>
  <li>criterion。默认有gini和entropy可选，到底哪个好现在还是有争论的。</li>
  <li>max_features，这个和n_estimators会一起影响整体结果，上文已经提到，可以参数换几个参数试试。</li>
</ol>

<h2 id="section-8">下一步计划</h2>

<p>研究下gradient boosting decision tree</p>

<h2 id="section-9">参考</h2>

<p><a href="http://en.wikipedia.org/wiki/Random_forest">1 wiki RF</a></p>

<p><a href="http://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm#inter">2 Random Forests Leo Breiman and Adele Cutler</a></p>

<p><a href="http://scikit-learn.org/stable/modules/ensemble.html">3 Ensemble methods</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[机器学习技巧之feature_hashing]]></title>
    <link href="http://whbzju.github.com/blog/2015/02/10/feature-hashing/"/>
    <updated>2015-02-10T15:58:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2015/02/10/feature-hashing</id>
    <content type="html"><![CDATA[<h2 id="section">问题</h2>

<p>最近在玩kaggle上的ctr比赛，其训练数据含大量categorical，无法直接用LR模型。举个例子，某个categorical数据集含[苹果，西瓜，梨，桃子]四个类别，一般的处理方法是将这些类别映射成[0,1,2,3]，放入模型中训练。其实这是不合理的，在categorical中，桃子和西瓜并不存在等级差，而变成[1,3]后会存在3&gt;1的问题。以Logistic Regression为代表的算法就无法对该特征学到合适的参数。因此，业界一般会对categorical数据集做onehotencoding，即向量化，还是以上面数据为例子，苹果对应的向量为[1,0,0,0]，桃子对应的为[0,0,0,1]。在sklearn中，可以通过OneHotEncoding或get_dummies实现。显而易见，数据会变得非常稀疏。同时，当categorical的类别变多，特征维度随之剧增，带来的内存存储问题。比如在这次的ctr中，如果采用OneHotEncoding，我60g内存的机器也会报Memory error。</p>

<p>再次，ctr领域或者说高维大数据领域，数据集或多或少的存在稀疏问题。主流ML库都会实现一套稀疏矩阵，应对该问题。feature hashing又称feature trick，类似于kernel trick，在ML领域得到广泛应用的技巧。
维基上的定义：</p>

<blockquote>
  <p>In machine learning, feature hashing, also known as the hashing trick[1] (by analogy to the kernel trick), is a fast and space-efficient way of vectorizing features, i.e. turning arbitrary features into indices in a vector or matrix. It works by applying a hash function to the features and using their hash values as indices directly, rather than looking the indices up in an associative array</p>
</blockquote>

<h2 id="section-1">解决方案</h2>

<p>维基上关于Feature Hash的描述非常清晰，各位自己去看，不再累赘，这里多说一点hash的方法。常见的有以下两种实现：</p>

<pre><code>function hashing_vectorizer(features : array of string, N : integer):
 x := new vector[N]
 for f in features:
     h := hash(f)
     x[h mod N] += 1
 return x
</code></pre>

<p>另外还有一种：</p>

<pre><code>function hashing_vectorizer(features : array of string, N : integer):
 x := new vector[N]
 for f in features:
     h := hash(f)
     idx := h mod N
     if ξ(f) == 1:
         x[idx] += 1
     else:
         x[idx] -= 1
 return x
</code></pre>

<p>可以理解，既然是hash，必然要付出collision时的代价。实现方案一并没有考虑处理冲突，N越长，冲突的概率越低，然后存储的要求会变大。实现二，通过有符号的hash来解决冲突问题，即有很大概率在出现冲突时，该hash值为0，即不起作用，更详细的描述参考文献2.</p>

<h2 id="sklearn-featurehasher">sklearn FeatureHasher的实现</h2>

<p><code>class sklearn.feature_extraction.FeatureHasher(n_features=1048576, input_type='dict', dtype=&lt;type 'numpy.float64'&gt;, non_negative=False)</code>，该接口返回一个sparse类型的array。</p>

<blockquote>
  <p>The hash function employed is the signed 32-bit version of Murmurhash3.</p>
</blockquote>

<p>该接口需要注意的是数据入参，支持三种格式：pair、dict和string。可以参考官方的<a href="https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/feature_extraction/tests/test_feature_hasher.py">featurehasher test</a>。</p>

<p>stackoverflow上也有一个比较好的例子：</p>

<p>Q:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">I am using FeatureHasher in scikit-learn.
</span><span class="line">
</span><span class="line">Can anyone explain why I end up with 4 non zero data in the sparse matrix instead of 2 after the following:
</span><span class="line">
</span><span class="line">&gt;&gt;&gt; f = FeatureHasher(input_type='string')
</span><span class="line">&gt;&gt;&gt; g = f.transform(('as','bs'))
</span><span class="line">&lt;2x1048576 sparse matrix of type '&lt;type 'numpy.float64'&gt;'
</span><span class="line">with 4 stored elements in Compressed Sparse Row format&gt;
</span><span class="line">&gt;&gt;&gt; g=f.transform(('as','bs'))
</span><span class="line">&gt;&gt;&gt; g.data
</span><span class="line">array([-1.,  1., -1., -1.])
</span><span class="line">&gt;&gt;&gt; g.nonzero()
</span><span class="line">(array([0, 0, 1, 1], dtype=int32), array([341263, 354738,  98813, 341263], dtype=int32))
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>A:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">It appears is expecting a sequence of sequences. The outer sequence being for the observations, and the inner being features. With your input, the inner sequence are the characters of the string.
</span><span class="line">
</span><span class="line">Observation 0: 'a' -&gt; 354738, 's' -&gt; 341263
</span><span class="line">
</span><span class="line">Observation 1: 'b' -&gt; 98813, 's' -&gt; 341263
</span><span class="line">
</span><span class="line">Try this:
</span><span class="line">
</span><span class="line">g = f.transform([['as'],['bs']])
</span><span class="line">For output:
</span><span class="line">
</span><span class="line">&gt;&gt;&gt; g.nonzero()
</span><span class="line">(array([0, 1], dtype=int32), array([494108, 335425], dtype=int32))</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">参考文献</h2>

<p>[1] <a href="http://en.wikipedia.org/wiki/Feature_hashing">Feature hashing From Wikipedia, the free encyclopedia</a></p>

<p>[2] <a href="http://alex.smola.org/papers/2009/Weinbergeretal09.pdf">Kilian Weinberger, Anirban Dasgupta, John Langford, Alex Smola and Josh Attenberg (2009). Feature hashing for large scale multitask learning. Proc. ICML.</a></p>

<p>[3] <a href="http://scikit-learn.org/stable/modules/feature_extraction.html">sklearn feature hashing</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git 实践]]></title>
    <link href="http://whbzju.github.com/blog/2015/02/07/git-practices/"/>
    <updated>2015-02-07T08:54:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2015/02/07/git-practices</id>
    <content type="html"><![CDATA[<h2 id="git-rebasegit-branch">git rebase和git branch</h2>
<p>svn过来的同学一定会觉得git的分支管理好方便，但更应该了解的是git rebase。可以说，用不用git rebase是区分你熟不熟悉git的重要方式。</p>

<h2 id="git-reset">git reset</h2>

<h2 id="git-fetchgit-pull">git fetch和git pull</h2>

<h2 id="git-commit--amend">git commit -amend</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014读过的书和参加的公开课]]></title>
    <link href="http://whbzju.github.com/blog/2015/01/02/2014-readlist/"/>
    <updated>2015-01-02T10:45:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2015/01/02/2014-readlist</id>
    <content type="html"><![CDATA[<h2 id="section">技术类</h2>

<h3 id="section-1">机器学习</h3>

<ol>
  <li>Pattern Recognizition and Machine Learning. 目前完成前四章，还没有完全吸收，希望2015的成长能够顺利吸收这本书的知识。</li>
  <li>推荐系统cookbook。感觉这本书有些落后于时代，大致翻了下。</li>
  <li>推荐系统实践–项亮。入门好读物。</li>
  <li>Frontiers in Massive Data Analysis。综述型，推荐。</li>
  <li>The Elements of Statistical Learning : Data Mining, Inference, andPrediction。当做工具书，还没有读多少，先把PRML搞定。</li>
  <li>kaggle solution分享。</li>
</ol>

<h3 id="python">Python</h3>

<ol>
  <li>python cookbook. 非常推荐。</li>
  <li>廖雪峰的python<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000">教程</a>. 简洁概要，实战内容有难度，很适合提供自己编程水平。</li>
  <li>python for data analysis。了解到pandas，数据分析利器。</li>
  <li>sklearn官方文档。图文并茂，极力推荐。</li>
  <li>pandas官方文档。例子丰富，入门先推荐10min那篇。</li>
</ol>

<h3 id="r">R</h3>
<p>粗略看了写文档。</p>

<h2 id="section-2">非技术类</h2>

<ol>
  <li>文明之光（上下），推荐，吴军博士的书质量一如既往。</li>
  <li>女士品茶。概率论发展史及大牛八卦。</li>
  <li>英语语法俱乐部–施元佑。大力推荐，介绍语法的来龙去脉。以前太不看重语法，阅读和写作的瓶颈。</li>
  <li>金字塔原理。</li>
  <li>思考的艺术</li>
  <li>如何阅读一本书</li>
  <li>数理统计简史</li>
</ol>

<h2 id="section-3">公开课</h2>

<ol>
  <li>Andrew Ng的Machine Learing。完成</li>
  <li>台大的机器学习基石。完成</li>
  <li>Functional Programming Principles in Scala。继续上</li>
  <li>Mining Massive Datasets，正在上</li>
  <li>機器學習技法 (Machine Learning Techniques)。正在上</li>
</ol>

<h2 id="section-4">互联网资讯</h2>

<ol>
  <li>咨询：依旧是知乎，目前没有看到什么能替代。</li>
  <li>kaggle，非常好的机器学习学习平台</li>
  <li>cousera，2015能学更多有价值的课程。</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[机器学习基石课程总结]]></title>
    <link href="http://whbzju.github.com/blog/2014/12/28/about-ml-fundation-course/"/>
    <updated>2014-12-28T11:07:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/12/28/about-ml-fundation-course</id>
    <content type="html"><![CDATA[<p>课程一开始，提了四个topic，what every machine learning user should know</p>

<pre><code>* when can ml learn
* why can ml learn
* how can ml learn
* how can ml learn better
</code></pre>

<h2 id="when-can-ml-learn">When can ml learn</h2>
<p>首先，机器学习针对的场景，通过<em>A</em>对<em>D</em>和<em>H</em>学习一个g，用来描述最终的目标f，而这个事情无法简单的用规则搞定。其次，澄清各类细分ml场景的定义：</p>

<pre><code>* 监督式
* 非监督式
* 增强学习
* 推进系统
* Activity学习，通过asking来学习
* Streaming
</code></pre>

<h2 id="why-can-ml-learn">why can ml learn</h2>
<pre><code>* shatter的概念
* break point的概念
* generation问题
* VC维的概念
</code></pre>

<h2 id="how-can-ml-learn">how can ml learn</h2>
<p>讲了一些基本的linear方法，比如logistic regression，顺便提了下nonlinear的问题，通过transform将nonlinear映射到linear可分的空间，有点类似核函数，需要进一步确认。</p>

<h2 id="how-can-ml-learn-better">how can ml learn better</h2>
<pre><code>* overfiting
* regularition，这块数学不错。从拉格朗日的constraint说起，到L1和L2的直观意义。
* cv
* 三个重要的Principle。Occam's Razor， Sample Bias， Data Snooping.
</code></pre>

<h2 id="section">我对这门课的收获</h2>

<pre><code>* 霍夫曼定理
* VC维的理解，线性相关
* 略微有点啰嗦，为了避免数学，导致描述的复杂度上升好几个级别
</code></pre>

<p>总体来讲，对工程人员帮助不是特别大，但有利于加深概念的理解。</p>

<to be="" continue="">
</to>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记第七届R语言大会]]></title>
    <link href="http://whbzju.github.com/blog/2014/11/30/r-language-conference/"/>
    <updated>2014-11-30T11:01:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/11/30/r-language-conference</id>
    <content type="html"><![CDATA[<p>这届R语言大会在杭师仓前校区举行，由阿里巴巴承办。邀请到了libsvm的作者林老师。但据同事说林教授演讲用的ppt都是一套（汗~~~）。上午是主会场，有四位嘉宾做了介绍，其他几位介绍的比较范，林稍微带点干货，特别提到数据没有到20T，不一定要上big data。下午是分会场，本人去听了：</p>

<ul>
  <li>分析师使用的R包</li>
  <li>京东的ctr模型</li>
  <li>天猫learning to rank</li>
  <li>天猫数据驱动运营。</li>
</ul>

<h2 id="section">点评</h2>

<ul>
  <li>京东分享推荐的ctr模型。和我街处于同一起跑线，模型和特征做法都很相似。赞下京东的分享着，讲的很实在。</li>
  <li>天猫l2r。没什么干货，介绍了一些基本概念就结束了。</li>
  <li>天猫数据驱动运营。预测销量，c2b。介绍的比较范，而且个人觉得他讲的效果有夸大的嫌疑。</li>
  <li>分析师用的R包。R中类似ipython notebook的东西。可交互的图，非常实用。</li>
</ul>

<h2 id="section-1">感想</h2>

<ul>
  <li>Spark出现的频率很高。</li>
  <li>用R来作云服务，我个人觉得不靠谱。</li>
  <li>libsvm的作者好有趣。演讲前看论文，演讲后睡觉。工业界范十足。</li>
  <li>学术界的分享依旧不靠谱。</li>
  <li>IBM关于电信领域的挖掘是来搞笑的吗</li>
  <li>接下来就等ppt了。</li>
</ul>

<p>最后，和阿里比，其他公司的所处的阶段还是非常的初级。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ipython notebook对机器学习工程师的价值]]></title>
    <link href="http://whbzju.github.com/blog/2014/11/23/ipython-notebook-bring-to-me/"/>
    <updated>2014-11-23T16:17:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/11/23/ipython-notebook-bring-to-me</id>
    <content type="html"><![CDATA[<p><strong>关键词</strong>：代码、数据、文档合一。</p>

<hr />

<p>如果选一个关键词来描述机器学习工程师的工作，不断试错是我心中的number one。相对于软件工程师来讲，有大量琐碎的dirty需要做，通常会占据到80%左右的时间。一个好的工具能够极大的提高效率。</p>

<p>总结需求如下：</p>

<ol>
  <li>可交互式的环境：比如预处理数据，有的时候数据比较大，比较耗时，希望能处理一次后就放在内存里面使用。</li>
  <li>文档化，记录工作流。数据挖掘会有非常多的idea要去尝试，实现这些idea的代码会有微小的差异，需要一个工具能够统一追踪管理他们。且不同的实验会有不同的结果，整理这些结果形成文档太费时间，希望能够做完实验就生成文档。</li>
  <li>经常会有一些片段代码要写，写在文件里有太零碎，写在交互式的shell里面有很难回溯，需要一个交互式和文档结合的工具。</li>
  <li>支持可视化工具，兼容python画图</li>
</ol>

<h2 id="ipython-notebook">神奇的ipython notebook</h2>

<h3 id="section">安装环境</h3>
<p>非常简单，推荐：Anaconda, <a href="https://store.continuum.io/cshop/anaconda/">官网</a></p>

<h3 id="ipython-notebook-1">ipython notebook入门</h3>
<p>还是<a href="http://ipython.org/notebook.html">官网</a>, 一开始不适应的同学，多看几个example吧。</p>

<h3 id="ipython-notebook-2">分享你的ipython notebook</h3>
<p>一键分享：<a href="http://nbviewer.ipython.org/">A simple way to share Jupyter Notebooks</a></p>

<h2 id="section-1">最后</h2>
<p>附一张我的在kaggle上用ipython notebook做的一个入门题照：
<img src="http://wujiarawsrc.qiniudn.com/sklearn-kaggle.png" alt="剧照" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[聚类算法中常见的距离计算方法]]></title>
    <link href="http://whbzju.github.com/blog/2014/11/22/ml-distance-measure/"/>
    <updated>2014-11-22T22:01:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/11/22/ml-distance-measure</id>
    <content type="html"><![CDATA[<h2 id="section">概述</h2>
<p>在面对聚类问题时，选择何种距离计算方法求相似度是一个basic question。文献[1]中提到了N多计算方法，从大类来看有以下几种：</p>

<ul>
  <li>$L_p$ Minkowski家族</li>
  <li>$ L_1 $ 家族</li>
  <li>Intersection 家族</li>
  <li>Inner Product家族</li>
  <li>etl
简单算一下大概有40+个计算方法，其中有好多没有听过。好在工业界一般只涉及到几个，本文将按自己理解大致介绍下这些方法及应用情况。</li>
</ul>

<h2 id="section-1">距离的类型和尺度</h2>
<p>类型：</p>

<ul>
  <li>二进制（binary）</li>
  <li>离散值（Discrete）</li>
  <li>连续值(Continuous)</li>
</ul>

<p>尺度：</p>

<ul>
  <li>定性：比如同义：red、green、black，比如顺序：高、中、低</li>
  <li>定量：
  a) interval
  b) ratio
距离的类型和尺度非常重要，影响后续聚类算法的选择。</li>
</ul>

<h2 id="section-2">距离计算方法定义</h2>
<p>严谨的定义参考[4]，通俗来讲，在一个空间内，距离计算方法满足以下4个公理。</p>

<ol>
  <li>$d(x,y) ≥ 0$</li>
  <li>$ d(x,y)=0$ if $x=y$</li>
  <li>$ d(x, y) = d(y, x)$ (distance is symmetric)</li>
  <li>$d(x, y) ≤ d(x, z) + d(z, y)$ (the triangle inequality).</li>
</ol>

<p>在欧式空间，第四个公理可以直观理解为两点之间距离最短。在其他情况需要一些证明才能推导。</p>

<h2 id="section-3">常见的距离计算方法</h2>

<h3 id="lr-norm">Lr norm</h3>
<p>在n维空间，其计算公式如下：</p>

<p>$d(x,y)=(\sum_{k=1}^{n} |x_k-y_k| ^r)^{1/r}$</p>

<ul>
  <li>
    <p>欧式距离
当r=2，这就是我们熟悉的欧式距离，其聚类形状在二维空间是一个圆。归属于$L_2$ norm</p>
  </li>
  <li>
    <p>曼哈顿距离
r=1，归属于$L_1$ norm，其名字的来源与该距离计算过程有关。该距离类似在x和y的每个维度上沿grid line上travel，类似曼哈顿的街道。</p>
  </li>
  <li>
    <p>$L_∞$ norm
当r不断变大，该式中只有max $|x_i-y_i|$项起作用，故又称L_max norm</p>
  </li>
</ul>

<h3 id="jaccard-distance">Jaccard Distance</h3>
<p>类似于相识度，x和y每个维度上相同的值的个数/总的维度。</p>

<p>The comparison of two binary vectors, p and q, leads to four quantities: </p>

<ul>
  <li>M01 = the number of positions where p was 0 and q was 1 </li>
  <li>M10 = the number of positions where p was 1 and q was 0 </li>
  <li>M00 = the number of positions where p was 0 and q was 0 </li>
  <li>M11 = the number of positions where p was 1 and q was 1 </li>
</ul>

<p>The simplest similarity coefficient is the simple matching coefficient </p>

<p>$ J = (M11) / (M01 + M10 + M11) $ </p>

<p>如：</p>

<ul>
  <li>a = 1 0 0 0 0 0 0 0 0 0</li>
  <li>b = 0 0 0 0 0 0 1 0 0 1
J = 0</li>
</ul>

<h3 id="cosine-distance">cosine Distance</h3>
<p>即余弦公式。求x和y两个特征向量的夹角。
cos( d1, d2 ) = (d1 • d2) / ||d1|| ||d2|| </p>

<h3 id="edit-distance">Edit Distance</h3>
<p>一般适用于String point。通过不断的删除和添加单个字符来计算两个string之间的距离。</p>

<h3 id="hamming-distance">Hamming Distance</h3>
<p>pass</p>

<h2 id="section-4">参考</h2>

<ul>
  <li>[1] Comprehensive survey on distance/similarity measures between probability density functions. SH Cha
City, 2007 - csis.pace.edu</li>
  <li>[2] An Introduction to Cluster Analysis for Data Mining</li>
  <li>[3] Unsupervised and Semi-supervised Clustering:
a Brief Survey</li>
  <li>[4] Mining of Massive Datasets - chapter 3</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coursera上Andrew Ng的机器学习课程评价]]></title>
    <link href="http://whbzju.github.com/blog/2014/09/13/machine-learning-at-coursera/"/>
    <updated>2014-09-13T21:49:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/09/13/machine-learning-at-coursera</id>
    <content type="html"><![CDATA[<h2 id="section">前言</h2>
<p>该课程非常适合初学者，比原先Ng在斯坦福大学的公开课要简单许多，少去了许多数学，并且在课程内容安排上更加紧凑，涉及的内容广泛，旨在搭建初学者与机器学习的桥梁。值得一提的是，该课程较为接近工程的角度，故我建议有兴趣的工程师可以尝试下。</p>

<p>本人花了3周左右的时间完成了该课程的视频和project，并拿到证书。每天下班回来比较晚，倒腾一两个小时，就该洗洗睡了，还好妹子理解。但不建议初学者像我一样，原因如下：</p>

<ul>
  <li>本人有一定的机器学习基础。</li>
  <li>虽然不熟悉octave，但是写过几年程序，能较快的适应它的语法。</li>
  <li>该课程没有中文字幕，不过Andrew Ng将的英文都比较简单，大家可以放心，我一般加速1.5x听。</li>
</ul>

<p>该课程有个较为合理的时间预估，可根据它安排学习计划。</p>

<hr />

<h2 id="section-1">内容介绍</h2>

<h3 id="section-2">建议先看视频</h3>

<p>Ng的视频和ppt做的非常有质量，简洁易懂。该课程有19个课程，每个课程一般有4-6个小视频，视频时间有长有短，最长的不会超过20分钟。下面列下个人觉得最有价值的部分：</p>

<ul>
  <li>Octave Tutorial，该教程能够帮你快速了解octave的基本用法，后续所有的project都会涉及到它。请对照该课程的讲义熟悉octave。PS：mac上安装octave可能会出些问题，我这边只要取消安装text help部分即可。</li>
  <li>主流算法，Logistic回归，SVM，ANN，Kmeans，PCA，协同过滤等，可以理解为通俗易懂版的讲解，不满足的同学建议去看看Ng在斯坦福公开课中的视频，那边会有较详细的数学推导。</li>
  <li>最为精华，即本人认为该课程最核心的部分是：X. Advice for Applying Machine Learning (Week 6)和XVIII. Application Example: Photo OCR。因为其他知识很容易得到，而且可以得到更好更完备的解释，而这两个视频，是Ng从工程的角度指导我们如何应用机器学习，并且给了一个实际的例子。</li>
</ul>

<h3 id="project">建议完成所有课程的project</h3>
<p>由于这些project的说明文档写的非常仔细，较为容易完成。通过写一些代码，可以对这些算法有更深的理解。另外，也可以认识到octave vectorizing写法的威力。</p>

<p>PS：请不要着急去网上搜课程答案，Ng在课程里面明确说明不要把作业答案放到网上，但还是有不少人放了自己的答案。提前看了答案，你会少很多乐趣。</p>

<hr />

<h2 id="section-3">总结</h2>
<p>后来也看了几个coursera上的课程，暂时还么有找到能和它一拚的课程。如果有哪位同学知道，可以分享下。
当然，这个课程只是个开始，后续可以看斯坦福大学的机器学习课程，同时配合Pattern Recognized and Machine Learning这本书效果会更好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown_gramma(转)]]></title>
    <link href="http://whbzju.github.com/blog/2014/04/08/markdown-gramma/"/>
    <updated>2014-04-08T22:46:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/04/08/markdown-gramma</id>
    <content type="html"><![CDATA[<p>个人收藏用，转：« <a href="http://wowubuntu.com">访问 Wow!Ubuntu</a></p>

<p><strong>NOTE:</strong> This is Simplelified  Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax">Markdown: Syntax</a>.</p>

<p><strong>声明：</strong> 这份文档派生(fork)于<a href="http://markdown.tw/">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md">查看这里</a> 。」–By @<a href="http://twitter.com/riku">riku</a></p>

<p><strong>注：</strong> 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/">GitCafe</a>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p>

<h1 id="markdown----basichtml">Markdown 语法说明 (简体中文版) / (<a href="./basic.html">点击查看快速入门</a>)</h1>

<ul>
  <li><a href="#overview">概述</a>
    <ul>
      <li><a href="#philosophy">宗旨</a></li>
      <li><a href="#html">兼容 HTML</a></li>
      <li><a href="#autoescape">特殊字符自动转换</a></li>
    </ul>
  </li>
  <li><a href="#block">区块元素</a>
    <ul>
      <li><a href="#p">段落和换行</a></li>
      <li><a href="#header">标题</a></li>
      <li><a href="#blockquote">区块引用</a></li>
      <li><a href="#list">列表</a></li>
      <li><a href="#precode">代码区块</a></li>
      <li><a href="#hr">分隔线</a></li>
    </ul>
  </li>
  <li><a href="#span">区段元素</a>
    <ul>
      <li><a href="#link">链接</a></li>
      <li><a href="#em">强调</a></li>
      <li><a href="#code">代码</a></li>
      <li><a href="#img">图片</a></li>
    </ul>
  </li>
  <li><a href="#misc">其它</a>
    <ul>
      <li><a href="#backslash">反斜杠</a></li>
      <li><a href="#autolink">自动链接</a></li>
    </ul>
  </li>
  <li><a href="#acknowledgement">感谢</a></li>
  <li><a href="#editor">Markdown 免费编辑器</a></li>
</ul>

<hr />

<h2 id="overview">概述</h2>

<h3 id="philosophy">宗旨</h3>

<p>Markdown 的目标是实现「易读易写」。
<!-- more -->
可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/">atx</a>、<a href="http://textism.com/tools/textile/">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>

<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>

<h3 id="html">兼容 HTML</h3>

<p>Markdown 语法的目标是：成为一种适用于网络的<em>书写</em>语言。</p>

<p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>

<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>

<p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>

<p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p>

<pre><code>这是一个普通段落。

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

这是另一个普通段落。
</code></pre>

<p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p>

<p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>

<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>

<h3 id="autoescape">特殊字符自动转换</h3>

<p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>

<p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p>

<pre><code>http://images.google.com/images?num=30&amp;q=larry+bird
</code></pre>

<p>你必须要把网址转换写为：</p>

<pre><code>http://images.google.com/images?num=30&amp;amp;q=larry+bird
</code></pre>

<p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p>

<p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp</code>;。</p>

<p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p>

<pre><code>&amp;copy;
</code></pre>

<p>Markdown 会保留它不动。而若你写：</p>

<pre><code>AT&amp;T
</code></pre>

<p>Markdown 就会将它转为：</p>

<pre><code>AT&amp;amp;T
</code></pre>

<p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="#html">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p>

<pre><code>4 &lt; 5
</code></pre>

<p>Markdown 将会把它转换为：</p>

<pre><code>4 &amp;lt; 5
</code></pre>

<p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p>

<hr />

<h2 id="block">区块元素</h2>

<h3 id="p">段落和换行</h3>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>

<p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p>

<p>如果你<em>确实</em>想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p>

<p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引用</a> 和多段落的 <a href="#list">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p>

<h3 id="header">标题</h3>

<p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/">atx</a> 形式。</p>

<p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p>

<pre><code>This is an H1
=============

This is an H2
-------------
</code></pre>

<p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>

<p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p>

<pre><code># 这是 H1

## 这是 H2

###### 这是 H6
</code></pre>

<p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p>

<pre><code># 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
</code></pre>

<h3 id="blockquote">区块引用 Blockquotes</h3>

<p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p>

<pre><code>&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre>

<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>

<pre><code>&gt; ## 这是一个标题。
&gt; 
&gt; 1.   这是第一行列表项。
&gt; 2.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     return shell_exec("echo $input | $markdown_script");
</code></pre>

<p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p>

<h3 id="list">列表</h3>

<p>Markdown 支持有序列表和无序列表。</p>

<p>无序列表使用星号、加号或是减号作为列表标记：</p>

<pre><code>*   Red
*   Green
*   Blue
</code></pre>

<p>等同于：</p>

<pre><code>+   Red
+   Green
+   Blue
</code></pre>

<p>也等同于：</p>

<pre><code>-   Red
-   Green
-   Blue
</code></pre>

<p>有序列表则使用数字接着一个英文句点：</p>

<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre>

<p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p>

<pre><code>&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
</code></pre>

<p>如果你的列表标记写成：</p>

<pre><code>1.  Bird
1.  McHale
1.  Parish
</code></pre>

<p>或甚至是：</p>

<pre><code>3. Bird
1. McHale
8. Parish
</code></pre>

<p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p>

<p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p>

<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>

<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>但是如果你懒，那也行：</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code> 
标签包起来，举例来说：</p>

<pre><code>*   Bird
*   Magic
</code></pre>

<p>会被转换为：</p>

<pre><code>&lt;ul&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>但是这个：</p>

<pre><code>*   Bird

*   Magic
</code></pre>

<p>会被转换为：</p>

<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>

<pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p>

<pre><code>*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You're
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
</code></pre>

<p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>

<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre>

<p>如果要放代码区块的话，该区块就需要缩进<em>两次</em>，也就是 8 个空格或是 2 个制表符：</p>

<pre><code>*   一列表项包含一个列表区块：

        &lt;代码写在这&gt;
</code></pre>

<p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p>

<pre><code>1986. What a great season.
</code></pre>

<p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p>

<pre><code>1986\. What a great season.
</code></pre>

<h3 id="precode">代码区块</h3>

<p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p>

<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>

<pre><code>这是一个普通段落：

    这是一个代码区块。
</code></pre>

<p>Markdown 会转换成：</p>

<pre><code>&lt;p&gt;这是一个普通段落：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一个代码区块。
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>

<pre><code>Here is an example of AppleScript:

    tell application "Foo"
        beep
    end tell
</code></pre>

<p>会被转换为：</p>

<pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application "Foo"
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>

<p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>

<pre><code>    &lt;div class="footer"&gt;
        &amp;copy; 2004 Foo Corporation
    &lt;/div&gt;
</code></pre>

<p>会被转换为：</p>

<pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class="footer"&amp;gt;
    &amp;amp;copy; 2004 Foo Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>

<h3 id="hr">分隔线</h3>

<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>

<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre>

<hr />

<h2 id="span">区段元素</h2>

<h3 id="link">链接</h3>

<p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p>

<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>

<p>要建立一个<em>行内式</em>的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>

<pre><code>This is [an example](http://example.com/ "Title") inline link.

[This link](http://example.net/) has no title attribute.
</code></pre>

<p>会产生：</p>

<pre><code>&lt;p&gt;This is &lt;a href="http://example.com/" title="Title"&gt;
an example&lt;/a&gt; inline link.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://example.net/"&gt;This link&lt;/a&gt; has no
title attribute.&lt;/p&gt;
</code></pre>

<p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>

<pre><code>See my [About](/about/) page for details.   
</code></pre>

<p><em>参考式</em>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>

<pre><code>This is [an example][id] reference-style link.
</code></pre>

<p>你也可以选择性地在两个方括号中间加上一个空格：</p>

<pre><code>This is [an example] [id] reference-style link.
</code></pre>

<p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>

<pre><code>[id]: http://example.com/  "Optional Title Here"
</code></pre>

<p>链接内容定义的形式为：</p>

<ul>
  <li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
  <li>接着一个冒号</li>
  <li>接着一个以上的空格或制表符</li>
  <li>接着链接的网址</li>
  <li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>

<p>下面这三种链接的定义都是相同：</p>

<pre><code>[foo]: http://example.com/  "Optional Title Here"
[foo]: http://example.com/  'Optional Title Here'
[foo]: http://example.com/  (Optional Title Here)
</code></pre>

<p><strong>请注意：</strong>有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>

<p>链接网址也可以用方括号包起来：</p>

<pre><code>[id]: &lt;http://example.com/&gt;  "Optional Title Here"
</code></pre>

<p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>

<pre><code>[id]: http://example.com/longish/path/to/resource/here
    "Optional Title Here"
</code></pre>

<p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>

<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：</p>

<pre><code>[link text][a]
[link text][A]
</code></pre>

<p><em>隐式链接标记</em>功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p>

<pre><code>[Google][]
</code></pre>

<p>然后定义链接内容：</p>

<pre><code>[Google]: http://google.com/
</code></pre>

<p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>

<pre><code>Visit [Daring Fireball][] for more information.
</code></pre>

<p>然后接着定义链接：</p>

<pre><code>[Daring Fireball]: http://daringfireball.net/
</code></pre>

<p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>

<p>下面是一个参考式链接的范例：</p>

<pre><code>I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        "Google"
  [2]: http://search.yahoo.com/  "Yahoo Search"
  [3]: http://search.msn.com/    "MSN Search"
</code></pre>

<p>如果改成用链接名称的方式写：</p>

<pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        "Google"
  [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
  [msn]:    http://search.msn.com/    "MSN Search"
</code></pre>

<p>上面两种写法都会产生下面的 HTML。</p>

<pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href="http://google.com/"
title="Google"&gt;Google&lt;/a&gt; than from
&lt;a href="http://search.yahoo.com/" title="Yahoo Search"&gt;Yahoo&lt;/a&gt;
or &lt;a href="http://search.msn.com/" title="MSN Search"&gt;MSN&lt;/a&gt;.&lt;/p&gt;
</code></pre>

<p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p>

<pre><code>I get 10 times more traffic from [Google](http://google.com/ "Google")
than from [Yahoo](http://search.yahoo.com/ "Yahoo Search") or
[MSN](http://search.msn.com/ "MSN Search").
</code></pre>

<p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>

<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>

<h3 id="em">强调</h3>

<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p>

<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre>

<p>会转成：</p>

<pre><code>&lt;em&gt;single asterisks&lt;/em&gt;

&lt;em&gt;single underscores&lt;/em&gt;

&lt;strong&gt;double asterisks&lt;/strong&gt;

&lt;strong&gt;double underscores&lt;/strong&gt;
</code></pre>

<p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>

<p>强调也可以直接插在文字中间：</p>

<pre><code>un*frigging*believable
</code></pre>

<p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>

<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>

<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre>

<h3 id="code">代码</h3>

<p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>`</code>），例如：</p>

<pre><code>Use the `printf()` function.
</code></pre>

<p>会产生：</p>

<pre><code>&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre>

<p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>

<pre><code>``There is a literal backtick (`) here.``
</code></pre>

<p>这段语法会产生：</p>

<pre><code>&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
</code></pre>

<p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>

<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre>

<p>会产生：</p>

<pre><code>&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre>

<p>在代码区段内，<code>&amp;</code> 和方括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>

<pre><code>Please don't use any `&lt;blink&gt;` tags.
</code></pre>

<p>转为：</p>

<pre><code>&lt;p&gt;Please don't use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre>

<p>你也可以这样写：</p>

<pre><code>`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre>

<p>以产生：</p>

<pre><code>&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded
equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;
</code></pre>

<h3 id="img">图片</h3>

<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>

<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p>

<p>行内式的图片语法看起来像是：</p>

<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg "Optional title")
</code></pre>

<p>详细叙述如下：</p>

<ul>
  <li>一个惊叹号 <code>!</code></li>
  <li>接着一个方括号，里面放上图片的替代文字</li>
  <li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上
选择性的 ‘title’ 文字。</li>
</ul>

<p>参考式的图片语法则长得像这样：</p>

<pre><code>![Alt text][id]
</code></pre>

<p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>

<pre><code>[id]: url/to/image  "Optional title attribute"
</code></pre>

<p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>

<hr />

<h2 id="misc">其它</h2>

<h3 id="autolink">自动链接</h3>

<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>

<pre><code>&lt;http://example.com/&gt;
</code></pre>

<p>Markdown 会转为：</p>

<pre><code>&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;
</code></pre>

<p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>

<pre><code>&lt;address@example.com&gt;
</code></pre>

<p>Markdown 会转成：</p>

<pre><code>&lt;a href="&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;"&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre>

<p>在浏览器里面，这段字串（其实是 <code>&lt;a href="mailto:address@example.com"&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「address@example.com」链接。</p>

<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>

<h3 id="backslash">反斜杠</h3>

<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p>

<pre><code>\*literal asterisks\*
</code></pre>

<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>

<pre><code>\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
</code></pre>

<h2 id="acknowledgement">感谢</h2>

<p>感谢 <a href="https://twitter.com/#!/leafy7382">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/">hlb</a>、<a href="http://twitter.com/randylien">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw">ethantw</a> 的<a href="http://ethantw.net/projects/han/">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/">WM</a> 回报文字错误。</p>

<p>感谢 <a href="https://github.com/fenprace">fenprace</a>，<a href="https://github.com/addv">addv</a>。</p>

<hr />
<h2 id="editor">Markdown 免费编辑器</h2>

<p>Windows 平台</p>

<ul>
  <li><a href="http://markdownpad.com/">MarkdownPad</a></li>
  <li><a href="http://code52.org/DownmarkerWPF/">MarkPad</a></li>
</ul>

<p>Linux 平台</p>

<ul>
  <li><a href="http://sourceforge.net/p/retext/home/ReText/">ReText</a></li>
</ul>

<p>Mac 平台</p>

<ul>
  <li><a href="http://mouapp.com/">Mou</a></li>
</ul>

<p>在线编辑器</p>

<ul>
  <li><a href="http://markable.in/">Markable.in</a></li>
  <li><a href="http://dillinger.io/">Dillinger.io</a></li>
</ul>

<p>浏览器插件</p>

<ul>
  <li><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog">MaDe</a> (Chrome)</li>
</ul>

<p>高级应用</p>

<ul>
  <li><a href="http://www.sublimetext.com/2">Sublime Text 2</a> + <a href="http://ttscoff.github.com/MarkdownEditing/">MarkdownEditing</a> / <a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/">教程</a></li>
</ul>

<p>*** 如有更好的 Markdown 免费编辑器推荐，请到<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/tickets/1">这里反馈</a>，谢谢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows tips]]></title>
    <link href="http://whbzju.github.com/blog/2014/04/07/windows-tips/"/>
    <updated>2014-04-07T10:00:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/04/07/windows-tips</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim tips]]></title>
    <link href="http://whbzju.github.com/blog/2014/04/07/vim-tips/"/>
    <updated>2014-04-07T10:00:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/04/07/vim-tips</id>
    <content type="html"><![CDATA[<p>收集我个人学习使用Vim的小技巧</p>

<h2 id="section">快速替换</h2>

<ul>
  <li>语法: [addr]s/源字符串/目的字符串/[option]</li>
  <li>[addr] 表示检索范围，省略时表示当前行。如：
    <ul>
      <li>“1，20” ：表示从第1行到20行；</li>
      <li>“%” ：表示整个文件，同“1,$”；</li>
      <li>“. ,$” ：从当前行到文件尾；</li>
    </ul>
  </li>
  <li>s：正则表达式中替换命令</li>
  <li>[option] : 表示操作类型
    <ul>
      <li>g 表示全局替换; </li>
      <li>c 表示进行确认</li>
      <li>p 表示替代结果逐行显示（Ctrl + L恢复屏幕）</li>
      <li>i 不区分大小写</li>
      <li>省略option时仅对每行第一个匹配串进行替换；</li>
    </ul>
  </li>
  <li>如果在源字符串和目的字符串中出现特殊字符，需要用”\”转义</li>
</ul>

<p>例子：将多个空格换成一个空格: %s/  */ /g</p>

<h2 id="section-1">多文件打开</h2>
<p>打开：split file<br />
切换窗口：双击ctrl+w，或ctrl+w+上下左右键</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu tips]]></title>
    <link href="http://whbzju.github.com/blog/2014/04/07/ubuntu-tips/"/>
    <updated>2014-04-07T09:59:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/04/07/ubuntu-tips</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[introduction to android adb]]></title>
    <link href="http://whbzju.github.com/blog/2014/03/30/introduction-to-android-adb/"/>
    <updated>2014-03-30T12:23:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/03/30/introduction-to-android-adb</id>
    <content type="html"><![CDATA[<p>Recently, I’m interesting how android adb works. If you are an Android programer, you certainly familiar with <code>adb shell</code>,<code>adb logcat</code>. Or maybe you only use eclipse, it is helpful to know behind DDMS there is adb.</p>

<h1 id="adb-overview">ADB overview</h1>
<p>We can find adb description from android developer website.
&gt;Android Debug Bridge (adb) is a versatile command line tool that lets you communicate with an emulator instance or connected Android-powered device. It is a client-server program that includes three components:</p>

<p>As introducted by google, it has three key components.</p>

<blockquote>
  <ul>
    <li>A client, which runs on your development machine. You can invoke a client from a shell by issuing an adb command. Other Android tools such as the ADT plugin and DDMS also create adb clients.</li>
    <li>A server, which runs as a background process on your development machine. The server manages communication between the client and the adb daemon running on an emulator or device.</li>
    <li>A daemon, which runs as a background process on each emulator or device instance.</li>
  </ul>
</blockquote>

<h1 id="basic-communication-model">Basic communication model</h1>
<p>We can make it clear through this picture.
<img src="http://whbzju.github.com/images/2014-03-25_adb_overview.png" alt="adb overview" /></p>

<ul>
  <li>
    <p>Daemon: which named adbd is a service which is started when android init, and it will be restarted when it died for some reason.</p>
  </li>
  <li>Service: run background on host, it act as a proxy use for transport. Or you may know android use binder to communication.</li>
  <li>Client: like <code>adb shell</code>, <code>adb logcat</code></li>
</ul>

<h1 id="command-detail">Command Detail</h1>
<p>Please reference <a href="http://developer.android.com/tools/help/adb.html">android developer</a></p>

<h1 id="how-can-i-connect-to-android-with-adb-over-tcp">How can I connect to Android with ADB over TCP?</h1>
<p>At last, we have this topic. As we know from above, adb use tcp/usb, so it certainly can be connected with network. If it works, we can debug android without usb, and more we can connect one device with mutil adb client by many developers. And I find solution like this:
###if your device is rooted
According to a post on stackoverflow, you can enable ADB over Wi-Fi from the device with the commands:</p>

<hr />
<p><code>su</code></p>

<p><code>setprop service.adb.tcp.port 5555</code></p>

<p><code>stop adbd</code></p>

<p><code>start adbd</code></p>

<hr />
<p>And you can disable it and return ADB to listening on USB with</p>

<p><code>setprop service.adb.tcp.port -1</code> </p>

<p><code>stop adbd</code></p>

<p><code>start adbd</code></p>

<h3 id="if-you-have-usb-access-already">if you have USB access already</h3>
<p>It is even easier to switch to using Wi-Fi, if you already have USB. From a command line on the computer that has the device connected via USB, issue the commands</p>

<p><code>adb tcpip 5555</code></p>

<p><code>adb connect IP:5555</code></p>

<h3 id="return-to-listening-over-usb">return to listening over USB</h3>
<p>Apps to automate the process by:</p>

<p><code>adb usb</code> </p>

<h3 id="proctocol">proctocol</h3>
<ul>
  <li>server
    <ul>
      <li>success: OKAY</li>
      <li>fail: FAIL</li>
    </ul>
  </li>
  <li>client
    <ul>
      <li>Message component with head which is 4 bytes indicate length of message, and follow is content. </li>
    </ul>
  </li>
</ul>

<h3 id="other">other</h3>
<p>There are also several apps on Google Play that automate this process. </p>

<h1 id="reference">Reference</h1>
<p><a href="http://events.linuxfoundation.org/images/stories/pdf/lf_abs12_kobayashi.pdf">lf_abs12_kobayashi</a></p>

<p><a href="http://developer.android.com/tools/help/adb.html">android developer</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2013年读过的书]]></title>
    <link href="http://whbzju.github.com/blog/2014/01/12/2013dushu/"/>
    <updated>2014-01-12T23:09:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2014/01/12/2013dushu</id>
    <content type="html"><![CDATA[<h2 id="section">技术类</h2>

<h3 id="c">C++</h3>

<ol>
  <li>esstianl c++，大学的时候读过，忘的差不多了。这次项目用到c++，为了快速上手，重读了一遍。评价五星。</li>
  <li>c++ prime。至今还没有通读，处于当手册使用的阶段，书中的例子很赞，可以作为c++ cookbook。</li>
  <li>effective c++。强烈推荐，不解释。</li>
  <li>effective stl，因为effective c++才买的，看了感觉和上一本的级别差太多，不推荐。</li>
</ol>

<p>这里推荐c++ reference这个网站，有很多优秀例子代码，是很好的参考对象。同时，该网站支持在线编译运行，很赞。</p>

<h3 id="c-1">C</h3>
<ol>
  <li>C专家编程。很赞，为它写了一篇简单的博客。</li>
</ol>

<h3 id="android">Android</h3>
<ol>
  <li>深入Android源码分析，卷一，邓平凡。强烈推荐，作者功力深厚，庖丁解牛。目前通读一遍，对JNI、Binder通信的理解加深许多。而像SurfaceFlinge这样的系统还没有很好的理解。</li>
  <li>深入Android源码分析，卷二，同。</li>
</ol>

<h3 id="section-1">机器学习</h3>
<ol>
  <li>斯坦福大学机器学习课程及讲义。入门的好材料。</li>
  <li>集体智慧编程。基于Python的机器学习常见算法教程。</li>
</ol>

<h3 id="section-2">代码质量、设计</h3>
<ol>
  <li>设计模式。GOF的，看一遍，感觉理解了，很快又会忘掉不少，每次做完项目重新看，都会有收获。</li>
  <li>google开源编程规范。</li>
</ol>

<h3 id="section-3">其他</h3>
<ol>
  <li>自己动手实现操作系统。</li>
  <li>深入理解C#</li>
  <li>effective Java</li>
</ol>

<h2 id="section-4">非技术</h2>

<ol>
  <li>德川家康—长篇推荐，感慨日本人名字的神奇</li>
  <li>冰与火之歌—魔龙狂舞，马丁爷爷一定要长命百岁</li>
  <li>浪潮之巅—-推荐</li>
  <li>活着活着就老了，冯唐</li>
  <li>小通鉴，冯唐</li>
  <li>人为什么活着，王小波</li>
  <li>地久天长，王小波</li>
  <li>走出软件磨坊</li>
  <li>精益创业</li>
  <li>创业四步法</li>
</ol>

<p>PS：今年上的最多的网站是知乎，感谢各位大牛热心分享知识。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS 10.9 安装scikit--万恶的墙]]></title>
    <link href="http://whbzju.github.com/blog/2013/12/29/wanerdeqiangheanzhuangscikit/"/>
    <updated>2013-12-29T14:26:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/12/29/wanerdeqiangheanzhuangscikit</id>
    <content type="html"><![CDATA[<h2 id="section">前言</h2>

<p>工作以来，接触不少机器学习相关的知识，一直听说python在这方面有许多优秀的工具，顺便自己也想学习python。经google后，决定安装scikit-learn试试。在官网上找到安装教程后，开心的发现支持brew。
<a href="https://gist.github.com/stared/4730202">安装教程</a></p>

<p>悲剧从此发生。。。brew需要安装的源许多都在SourceForge上，但是该网站被天朝强大的“墙”屏蔽了。没有办法一键安装。</p>

<h2 id="section-1">源码安装</h2>
<p>我也很纳闷为什么brew的源大部分在SourceForge上，为何不用GitHub的。既然不能一键安装，那我通过源码安装总可以吧。
scikit需要numpy和scipy两个重要的组件，在scipy官网找到<a href="http://www.scipy.org/scipylib/building/macosx.html">安装教程</a>.</p>

<p>在安装scipy的提示</p>

<pre><code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can't open input file:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can't open input file:
</code></pre>

<p>在查阅了一些资料后，问题貌似是由于xcode 5版本和xcode 4在工具链上有不少调整导致的，试了几种方法后未能解决。</p>

<h2 id="brew-">brew 撞墙怎么办</h2>
<p>参考网上资料，只有自己把文件下好，放到 /Library/Caches/Homebrew/ ，但是如果文件很多，就悲剧了。</p>

<h2 id="section-2">不要轻易更新系统</h2>
<p>在解决了brew撞墙问题后，继续尝试brew安装，依旧没有成功，提示xcode5版本太新，</p>

<pre><code>make: *** [bootstrap] Error 2
Error: Homebrew doesn't know what compiler versions ship with your version
of Xcode (5.0.2).
</code></pre>

<h2 id="section-3">未完待续</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在手机上实现高精度及自适应多种场景的计步器算法]]></title>
    <link href="http://whbzju.github.com/blog/2013/12/27/pedometer/"/>
    <updated>2013-12-27T22:58:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/12/27/pedometer</id>
    <content type="html"><![CDATA[<h1 id="section">前言</h1>
<p>随着当前智能终端的普及，人们可做的事情变得越来越有趣，比如计步器。传统的计步器一般是一个单独的设备，戴在身体的某个位置，由于必须在用户身上增加一个设备，推广起来有一定阻力。其实，计步器只需要一个3-轴加速度传感器就能做到较高的记步精度，类似三星note3的计步器精度在95%以上。当前智能手机一般都含有加速度传感器，许多人开始在手机上做计步器。可惜目前Android市场上大多数计步器精度都不理想，经本人测试，目前最好的是三星的note3的健康伙伴，更关键的是三星使用了sensorhub的技术，在保持精度的同时，做到了超低功耗。
在手机上做计步器相较于传统的计步器最大的难点在于手机使用时位置不固定，计步器要能适应不同放置位置和不同走路场景，这就要求计步器算法有很好的动态调整能力。</p>

<h1 id="section-1">计步器模型介绍</h1>
<p>关于人走路的模型，前人[1]已经做了很多研究，不再累赘。总结来讲，人在走路时，加速度传感器会形成一个类似正弦波形图，因此可以根据检测波峰波谷记步。见下图：</p>

<p><img src="http://whbzju.github.com/images/pedometer.png" alt="步伐传感器数据波形图" /></p>

<h1 id="section-2">算法</h1>

<h2 id="section-3">概述</h2>
<ol>
  <li>特征选取</li>
  <li>滤波</li>
  <li>基于动态阈值检测步数</li>
  <li>步数矫正</li>
</ol>

<h2 id="section-4">特征选取</h2>
<p>考虑到手机在不同放置情况下传感器的每个轴会有不同表现，因此，取其强度特征可以避免该类问题，即取三轴平方和。</p>

<h2 id="section-5">滤波</h2>
<p>滤波是一种常见的数据预处理方法，特别是手机上加速度传感器数据存在一定的噪音，经过滤波后能得到较平滑的数据。滤波算法有许多中，常见的有数字滤波，也可以叫中值滤波、高斯滤波、快速傅里叶变换。本人试过几种滤波算法后，发现采用中值滤波即可满足需求，因为算法的瓶颈并不在此。另一个考虑是终端的计算资源有限，过多的计算将造成大量的耗电。</p>

<p>简单来讲，即取一个时间窗做平滑，假设以50HZ的频率采集加速度传感器数值，即在Android中注册Sensor频率为Fastest（不同手机可能会有差异）。我采用5个数据做一次平滑，即收到5个数据算一次平均值，当做当前值。当然，你可以增加时间窗长度，但是需要考虑用户体验，不能延迟太久。</p>

<h2 id="section-6">动态阈值</h2>
<p>通常，计步器有两种思路：一种是通过计算过零率来记步；另外一种是计算极大值和极小值，判断峰谷值来记步。两种算法的思想类似，都需要设置阈值。为了适应各种不同的位置和走路姿势，你不能简单设一个阈值来检测步数。第一种方法容易出现误记，需要结合其他方法排除在mean值附近抖动的数据。第二种方法容易出现漏检，同时如果误记，还会影响到后续的记步，因为在一次步伐中出现好几个峰谷是很正常的，如何去除这些数据的影响需要良好的设计。</p>

<p>本人采用的检测峰谷值得方法记步，但不是通过计算极大值和极小值，而是设置波峰的阈值和波谷的阈值，即当数据大于波峰阈值时，都记为未确认峰值，保存其中最大的一个，这样可以避免数据在上升途中偶尔出现的抖动。同理，作用于峰谷。
检测出峰谷之后，通过保存一个时间窗，通过里面的峰谷个数记步。这里更多的是工程上的设计。</p>

<h2 id="section-7">步数矫正</h2>
<p>基本思想是人类走路的特性，人的步伐速度在200-2000ms之间，通过记录记步的时间戳，矫正步数。步伐间隔&lt;200ms和&gt;2000ms，认为是无效步数。这部分也是目前终端计步器算法的核心，做的好的公司都有相应的矫正机制。</p>

<h1 id="section-8">总结</h1>
<p>计步器算法的基本思想大致如此，最终产品的表现还要不断打磨，针对异常场景进行优化。最后，终端设备上应用不可避免的是功耗问题，如果开了计步器，你的手机用半天就没电，估计没人愿意用。目前市场上许多低功耗计步器算法，大多以降低精度为代价。目前看来只有三星采用高通的sensorhub方案有较好的表现。</p>

<p>参考：</p>

<p>[1] <a href="http://www.analog.com/library/analogDialogue/china/archives/44-06/pedometer.html">利用3轴数字加速度计实现功能全面的计步器设计</a></p>

<p>[2] <a href="https://github.com/bagilevi/android-pedometer">Github上的一个计步器实现代码</a> 改代码直接使用效果不好</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程小扎之回调]]></title>
    <link href="http://whbzju.github.com/blog/2013/09/20/bianchengzhihuidiao/"/>
    <updated>2013-09-20T14:49:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/09/20/bianchengzhihuidiao</id>
    <content type="html"><![CDATA[<p>在我的认知中，编程最需要要关心的是数据结构和消息机制。进一步，即模块功能的定义，以及模块之间的通信。这和编程中的回调机制十分类似。回调在wiki中有如下定义：
&gt; In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time. The invocation may be immediate as in a synchronous callback or it might happen at later time, as in an asynchronous callback.
The ways that callbacks are supported in programming languages differ, but they are often implemented with subroutines, lambda expressions, blocks, or function pointers.</p>

]]></content>
  </entry>
  
</feed>
