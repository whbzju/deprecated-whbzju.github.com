<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[知行录]]></title>
  <link href="http://whbzju.github.com/atom.xml" rel="self"/>
  <link href="http://whbzju.github.com/"/>
  <updated>2013-06-23T09:28:17+08:00</updated>
  <id>http://whbzju.github.com/</id>
  <author>
    <name><![CDATA[阿波]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[入职两月总结]]></title>
    <link href="http://whbzju.github.com/blog/2013/06/23/ruzhilianggeyuezongjie/"/>
    <updated>2013-06-23T09:01:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/06/23/ruzhilianggeyuezongjie</id>
    <content type="html"><![CDATA[<p>好久没有写博客，一是工作后时间不是自己，每天很晚下班，回到家，洗洗差不多就要睡了。二是公司信息安全管的很严，资料带不出来，工作方面的积累不方便写到博客上，每次想起要重新写自己写过的东西，就很没有动力。</p>

<p>本周过后，入职已经两个月了，公司的体制不想也没有资格评论，做的项目确是我很满意的，只能说塞翁失马焉知非福，找工作的时候千挑万选，也看不清进来后的项目，目前的情况还算幸运。现在的项目组涉及到的领域有Android开发、人脸识别、机器学习等，而且作为一个新的项目，我有幸可以从头开始接触整个项目。</p>

<h2>成长</h2>

<ul>
<li>Android源码环境调试app、系统组件</li>
<li>Android 4.0 人脸解锁app研究</li>
<li>Android JNI技术学习</li>
<li>人脸识别算法PCA、FDA、LBP学习</li>
<li>人脸检测HaarCascade学习</li>
<li>Opencv 人脸识别 Demo研究：Eigenface、fisherFaces、LBP。</li>
<li>机器学习LDA、贝叶斯学习</li>
</ul>


<h2>博客计划</h2>

<p>后续博客将集中在三个领域</p>

<ul>
<li>Android技术：分为源码和应用开发技术</li>
<li>人脸识别：集中于机器学习的方式实现</li>
<li>机器学习：未来重点</li>
</ul>


<p>计划中的blog：</p>

<ul>
<li>Android JNI技术简介</li>
<li>Android调试小技巧</li>
<li>PCA之我的理解</li>
<li>fisherFaces之我的理解</li>
<li>Opencv人脸识别Demo</li>
<li>ADB的使用详解</li>
<li>Haar分类器训练</li>
</ul>


<p>欠了好多，这些内容我在公司都有写过文档，可惜不能直接用，希望在整理的过程中有进一步的理解。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android JNI MAC OS环境配置]]></title>
    <link href="http://whbzju.github.com/blog/2013/06/01/android-jni-config/"/>
    <updated>2013-06-01T23:50:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/06/01/android-jni-config</id>
    <content type="html"><![CDATA[<h2>前言&#8212;JNI技术简介</h2>

<p>JNI是Java Native Interface的缩写，即“Java本地调用”，它是Java世界和Native世界的中介桥梁。其中Native世界一般指C/C++的世界。众所周知，Java是一种跨平台的语言，即Java编写的应用与平台无关。但是，计算机的世界在Java出现之前已经发展了很久，有很多优秀健壮的代码可以复用。比如Linux下的好多驱动模块、文件系统等。Java若去重新实现这些功能，未免费力不讨好，落下重复造轮子的名声。通过JNI技术，使用这些Native的模块，便成了一个折中的办法。同时，Java的世界依靠虚拟机构建，而虚拟机是native语言实现，并且虚拟机运行在具体的平台上，所以虚拟机本身是无法做到平台无关。通过JNI技术，可能做到在Java层的平台无关，即在Java层，底层的细节完全被屏蔽掉了。综合来讲，JNI技术一直支撑这Java世界，只不过我们平时接触的较少。</p>

<p>在Android的世界里，不允许纯C/C++的程序出现，但是它支持JNI，通过JNI来实现java和C/C++的交互。因此，JNI对于需要接触到Android源码、底层驱动、图形图像等领域的开发者来讲异常重要。</p>

<p>在Android中，Native语言实现的代码最终要编译成*.so动态库的方式，供java层调用，目前有两种途径实现。</p>

<h2>两种编译环境</h2>

<ul>
<li>源码编译环境：Android平台提供基于Make的编译环境，为App正确的编写Android.mk即可使用该编译环境，该环境需要通过git从Android的官方的源码平台获取源码并编译，得到环境。具体见：<a href="http://source.android.com/index.html">http://source.android.com/index.html</a></li>
<li>基于Android NDK的编译环境:NDK的全称叫做Native Development Kit。是google提供给我们用于本地编译JNI的工具。事实上，NDK和源码编译环境一样，都是使用Android的编译系统，通过Android.mk来控制编译。本文重点介绍这种方式。</li>
</ul>


<h2>NDK编译环境</h2>

<p>在Mac下，配置NDK的环境十分简便，你只需要去<a href="http://developer.android.com/tools/sdk/ndk/index.html">官网</a>下载ndk包，前提是你已经安装好ndk需要的工具，一般你如果安装过xcode，基本的环境都会有。解压缩到任意一个目录下，把该目录加到你的PATH中即可。比如我的：</p>

<p>在~/.bash_profile中把路径加入PATH，如果没有，可以创建一个.bash_profile，在最后加入下面语句。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export PATH=$PATH:/Users/youpath/android-ndk-r8e</span></code></pre></td></tr></table></div></figure>


<p>重启bash，即可使用ndk-build</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HaibotekiMacBook-Air:jni haibowu$ source ~/.bash_profile
</span><span class='line'>HaibotekiMacBook-Air:jni haibowu$ ndk-build
</span></code></pre></td></tr></table></div></figure>


<h2>运行Hello-jni</h2>

<p>ndk包解压缩之后，自带一些jni的例子，下面我们就来编译运行下hello-jni，感觉下jni的世界。该demo的路径在ndk安装路径的sample目录下。进入该路径，执行下列命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HaibotekiMacBook-Air:jni haibowu$ ndk-build
</span><span class='line'>Gdbserver      : [arm-linux-androideabi-4.6] libs/armeabi/gdbserver
</span><span class='line'>Gdbsetup       : libs/armeabi/gdb.setup
</span><span class='line'>Compile thumb  : hello-jni &lt;= hello-jni.c
</span><span class='line'>SharedLibrary  : libhello-jni.so
</span><span class='line'>Install        : libhello-jni.so =&gt; libs/armeabi/libhello-jni.so</span></code></pre></td></tr></table></div></figure>


<p>当系统提示生成*.so文件时，即代表编译成功。可以通过eclipse或者intellij idea导入该工程，运行查看效果。</p>

<h2>其他</h2>

<ul>
<li>如果你有android源码编译环境，你可以通过编写android.mk来编译app</li>
<li>如果你是在window下使用ndk，你需要安装cygwin，来模拟linux的环境，才能把ndk安装成功，其思想是一直的。参考：<a href="http://www.cnblogs.com/luxiaofeng54/archive/2011/08/13/2136982.html">http://www.cnblogs.com/luxiaofeng54/archive/2011/08/13/2136982.html</a></li>
<li>ndk是一个开发工具包，你也可以查看它的源码、进行编译，具体参考：<a href="http://glandium.org/blog/?p=2146">http://glandium.org/blog/?p=2146</a></li>
</ul>


<h2>后续</h2>

<p>接下来，我会写一篇介绍Jni的blog，希望能写的浅显易懂。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[李安家庭三部曲杂想]]></title>
    <link href="http://whbzju.github.com/blog/2013/03/29/lianjiatingsanbuqu/"/>
    <updated>2013-03-29T14:10:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/03/29/lianjiatingsanbuqu</id>
    <content type="html"><![CDATA[<p>最近少年PI的漂流很火，很少见的微博上一致的好评，可惜妹子正值考研的关键阶段，不好打扰。再加上自己经济上实在是拮据，也不想多给家里增添负担，只好作罢。至今为止有两部电影很想看却没看成，一部是它，另一部是阿凡达。当然，其中缘由大相径庭，谁叫生活变化这么快呢。</p>

<p>写东西，对我来讲是自身思维的整理，把我想的虑的形成文字表达出来。一个是我觉得自己最近的思路混乱，经常无法将一个问题描述清楚，逻辑上缺乏锻炼，或者也有可能是自己对问题本身并没有一个成型的思路。所以最近想把内心的东西挖出来，写点东西理一理，再次加工。</p>

<p>李安的电影我其实看的很少，小的是看过卧虎藏龙，后来读研的时候重新回顾了一遍。这个导演把每个镜头都拍的很美，很用心，在讲他想讲的东西，拍他想给我们看得东西，于是，整个片子中透露着一种美。真正的艺术家，不会去迎合大众，不会去矫揉造作，他应该做他自己，展现出他想展现的，不带名利的枷锁，这样的作品中自然透露着一种美。请允许我不断的用美这个词汇，因为我词穷。当一个艺术家在创作时不是往自己的内心挖掘，而开始在意外界的元素时，比如名利，就是他艺术消亡的开始。</p>

<!--more-->


<p>虽然没有机会看少年PI的漂流，只好抽空看了他的家庭三部曲：饮食男女、推手、喜宴。其中我最喜欢的饮食男女，依然是唯美的画面，缓慢的节奏，虽然在剧情安排上有点出入意料，总体还是充满生活气息。看李安的电影，一定要在心境平实的时候，镜头通常是缓慢柔和，剧情温润如玉，会让你觉得这就是生活。特别是里面那些下厨的镜头，美得惊心动魄，我要变成李安的脑残粉了。</p>

<p>剧中每个人都有一个梗，你越是努力去拔，越是徒劳，生活常常不经意间跟你开个玩笑，打乱你的平静。就像吃东西，你吃的再精致，也不会比别人得到更多的能量，怎么都是个吃，何必处处讲究，那不过是自己的梗，自己和自己较劲较真。只有你把它当回事，它才是回事，其实它远没有你想象的那么重要，没有它，世界依旧继续。就像没有你，世界也不会有什么不同。母亲死后，大姐把自己放在了母亲的位置，没了自己，为了让自己显得理所当然，她为自己编织了一个梦，姐妹需要她这么做，爸爸需要她这么做，连爱人她也可以编织一个出来。父亲每星期的家庭聚餐，与其说是维持家庭感情，不如说是为自己营造一个被人需要的感觉。人真是一种很奇怪的动物，人会自己给自己设立许多自己决定正确的事情，然后一刀切的实施到他人身上。</p>

<p>推手里面最喜欢的画面是儿子在牢房里面探望老头子，痛哭流涕。拼命读书，留学，努力工作，就是希望能把爸爸接到美国来过几天好日子。最终的现实却是不断的相互折磨，不开心。年轻的时候，总觉自己聪明、勤奋，世界就在自己的手中，可以捏成自己想要的摸样。给自己设了一个个目标，以为做到了就能得到幸福。可惜，人生来好像就是受苦受磨难一般，总是出乎意料的让你无所适从。这些镜头不免让人想到自己，我们也一样为自己画了一个美丽可口的饼，然后告诉自己完成这些目标就能吃到那个饼，就是不知道吃到的饼还是不是自己从前想要的那个饼。</p>

<p>可是生活还在继续，我们得活下去，若没有那么多硬性的要求，要赚多少钱，要让父母多开心，多放下一些会不会好一些呢？谁知道呢，写了半天，我们还是会按照原来的路子走的。</p>

<p>PS：写完发现文字好悲观，可能正是这些悲观，才能让自己对得失释然一些，才会显得更加乐观，因为生活不会因为悲观就变好起来是吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Macbook air上手心得]]></title>
    <link href="http://whbzju.github.com/blog/2013/03/24/mac-test/"/>
    <updated>2013-03-24T00:33:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/03/24/mac-test</id>
    <content type="html"><![CDATA[<h1>购机</h1>

<p>即将毕业，手头正在用的Thinkpad 410要还给实验室，而原来本科时候用的benq S41突然坏了。没办法，还没有开始赚钱，却要先败家了。年前开始看笔记本，自从用了TP的机子后，很喜欢它的做工，用了3年，硬件上没出过什么问题。在电脑城逛了一圈，实在看不上其他品牌笔记本的做工（当时还没有考虑Apple），于是准备再入一个T430，价格在8k左右。我现在对电脑的需求如下：</p>

<ul>
<li>稳定，性能过得去，做工好。</li>
<li>轻便，易携带</li>
<li>主要是编程和写文档，不考虑玩游戏。</li>
<li>主要工作环境是Linux</li>
</ul>


<p>对于T410，我最大的不满是它太重了，刚开始还没有特别多的感觉，后来几次出差，背着它站一天，或者是回家的时候，看到它就觉得重，对自己来讲是个不小的折磨。由此，产生了买超级本的需求，看上了TP的T430U，当然也看了X1，不过X1实在太贵了，不是我们这种刚毕业的同学可以考虑的。在查阅了一些资料之后发现，T430U是混合硬盘，其效用只有在win的环境下才能得到发挥，而我对window越用越慢，一两年必须得重装的问题无法忍受，只好放弃它。</p>

<p>在和同学聊起买机子的烦恼，flyingShang同学推荐我买mba，他自己用了2年，小彬同学也用了一年多，只有一个评论，<strong>再也不想用别的电脑了</strong>。鉴于这两位好基友的推荐，开始考虑Mac，刚开始的时候担心air的性能，看了几款pro。新出的rmbp真的是很有吸引力，带retina屏，强悍的性能，价格比air贵一些，而且比原来的pro轻了不少。考虑到将来工作后主力机不是这台笔记本，还是省点钱吧，最终决定如个air。</p>

<p>小彬同学的air是在<a href="http://www.appletuan.com/">苹果团</a>上购买，mba 231低配8g定制版。于是我也想在上面买个一样的。可是等了好久，都不见231定制版的出现，只好向团主询问，得知他们不再发起mba 231 8g定制版的团购了，需要等到年中的时候，苹果出新款mba时，他们会组织团购新款。伤心之余只好死心，第二天在团上入了个mba 231低配，买的过程中被网银和信用卡恶心了，我的网银不知道怎么过期了，信用卡又被支付宝限额，折腾了好久才付款成功（第一次网购如此揪心）。隔一天后，机子到了，然后就是这几天一直在折腾、适应。</p>

<h1>Mac系统初体验</h1>

<p>刚上手的mac感觉和Thinkpad完全不一样，TP会让你觉得精干、耐*，而mac会让你有好好珍惜它的冲动。总体的做工和外观没什么可以挑剔，屏幕比我想象中的好，特别是比我的T410好，原来的T410在色彩成像上我比较不满意，有一次给同学做个页面，我这边看起是蓝的，在他机子上成了绿色。键盘我个人还是更喜欢T410的，不过适应一阵子应该还行。大赞的是air的触摸板，我没有买鼠标，觉得air是不需要鼠标的。</p>

<h3>触摸板手势操作</h3>

<p>刚买到的air在使用时，触摸板必须按下才能有点击效果，这个可以在系统偏好设置中对触摸板进行设置。而且在该设置界面，就有良好的用户教程，通过gif（动态图片的形式）说明每个手势的作用。不能说那个手势用的最多，我在该设置中启用了所有的手势，而且现在基本上每个手势都在用。感觉比较深的是，通过结合多个桌面，将不同的工作内容放在不同的桌面（通过四个手指向上的手势调整分配），再结合四个手指左右切换的手势或者是command+tab/command+shift+tab，能够极大的提高工作效率。</p>

<h3>Mac系统使用逻辑简要心得</h3>

<!--more-->


<h4>左上角系统栏跟随当前应用程序</h4>

<p>当你选中一个应用程序时，整个系统都会focus到它上面，该应用程序所有相关的设置和操作都会在左上角的系统栏上显示。这个逻辑和iOS的逻辑非常一致，尽可能的简化操作逻辑，减少菜单层级，用户在面对对不同应用程序可以拥有统一的操作体验。想必windows的用户肯定对此有很深的感触，比如Office的设置和Acrobat Adobe pro的设置就不统一，我当年第一次用Adobe，想设个参数，对这它的菜单栏找了许久，令人抓狂的体验。</p>

<h4>类似OSGi bundle的即插即拔的软件安装加载方式</h4>

<p>mac下的安装文件大部分是dmg格式，在安装时，会出现一个拖放安装界面，只要将该应用程序的图标拖放到Application中，系统便会将它安装好。就像一个组件，只要加载到系统上即可。不严谨的说法是软件就像U盘，插上能用，拔掉就可以删除。所以mac在安装软件时，会先mount即加载这个软件，这个时候桌面上有出现被加载的软件的图标，安装完毕可以选中将其弹出。
我一直很喜欢OSGi的设计思想，将软件以组件的形式发布，通过OSGi框架来统一管理，每个软件可以做到热插拔，安装方式非常方便，而且某种程度上更加安全。Mac的软件安装方式是非常符合程序员的逻辑思维，或者说，更像人类的思维，如过你没有被window的软件安装方式先入为主的话。</p>

<h4>Finder统一文件管理</h4>

<p>Mac基于Unix，其文件管理系统没什么变化，所有用户的东西被放在/Users/yourname下面。Finder是整个文件系统的UI，结合spotlight，其实你不用整理文件，也能非常迅速的找到你想要的。</p>

<h4>常用快捷键</h4>

<ul>
<li>command + Q：结束当前应用程序。</li>
<li>command + C：复制</li>
<li>command + V：粘贴</li>
<li>command + tab/ command + shift + tab: 向前和向后切换程序</li>
<li>command + delete/command + shift + delete: 清空废纸娄和彻底清空废纸篓</li>
<li>command + option + esc：强行退出程序</li>
<li>command + shift + 3：截图，当前屏幕</li>
<li>command + shift + 4：自由截图</li>
</ul>


<h4>建议学些简单常用的终端命令</h4>

<p>Mac的Unix血缘估计是很多程序员喜欢它的原因，基本上从linux上过渡而来的同学可以很快上手。</p>

<h3>Mac装机软件推荐</h3>

<ul>
<li>Alfred： 免费软件，可以快速打开应用，用option+space打开。很多人觉得已经有Spotlight，没必要用它，我只是想说，试试它后你再说吧。现在它有2.0版，加入了workflow，很多大牛在上面实现了许多很有意思的东西，有兴趣大家可以google下。</li>
<li>spotlight：系统自带。快速查找定位。很好用，control+space打开，还可以在里面直接查单词。</li>
<li>输入法：搜狗输入法 for mac，linux上没有好用的中文输入法，这个也是我买mac的重要原因之一。</li>
<li>播放器：mplayer，Apple store上可以下，是免费的，基本上能支持主流的视频格式。</li>
<li>iWork：据说很好用。</li>
<li>xtraFinder：很好用的Finder插件，可以让多个Finder窗口想chrome标签一样进行管理。</li>
<li>Office for mac：同学说还是和win下的office有些不兼容，所以我没装。我选着用虚拟机装个win 7，在上面装office，以便以后的一些需要。</li>
<li>虚拟机：最好用的应该parallel desktop，不过是付费软件，淘宝上买买也不是很贵，可以入一个。VMware也不错，也是收费软件。Virtual box是免费的，体验相对差一些。我在试用parallel，装了win 7，在ssd的帮助下，正常使用完全感觉不出什么差异，主要用作网银和与win兼容的内容。</li>
<li>邮件：mac自带的就不错。有个小软件叫sparrow，很多人推荐，不过是付费的。</li>
<li>QQ for mac：感觉还行。</li>
<li>浏览器：一直都用chrome，很多历史数据在上面，不好迁移，safari其实也还可以。</li>
<li>Dropbox：推荐各位使用，用了有一年多了，跨平台同步很好用。</li>
<li>Wiznote：用过有道、evernote，最终还是用了wiz，基本满足我的需要。这个是国内的团队做的，一个小公司，很用心。</li>
<li>豆瓣FM：不解释</li>
<li>kindle for mac：有kindle的同学一定要下这个，直接在亚马逊上下载会提示不支持中国用户，到第三方站点下一个，可以同步kindle上的资料在mac上看。</li>
<li>终端：iterm2，非常强大的终端，比自带的好用，可以调整配色，让你的终端变的很好看。</li>
<li>Xcode：开发的同学建议安装，或者装个command line tools，很多环境会自动配好。</li>
<li>Homebrew：类似与ubuntu下的apt-get，总体还行，稍微有点不给力。</li>
<li>编辑器：可以装个MacVim，我个人觉得没区别，用Vim就可以了。不过要推荐下<strong>Mou</strong>，支持markdown的编辑器，我这篇文章就是用它写的。</li>
</ul>


<p>暂时写这么多先，后面再慢慢补充吧，最后上传一张系统截图：
<img src="http://whbzju.github.com/images/macSncat.png" alt="截图" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress custom-configuration 个性化配置]]></title>
    <link href="http://whbzju.github.com/blog/2013/03/01/octopress-custom-config/"/>
    <updated>2013-03-01T09:25:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/03/01/octopress-custom-config</id>
    <content type="html"><![CDATA[<h1>概述</h1>

<p>我使用的octopress默认的主题，但是它的一些页面设置不能满足我的需求。比如：</p>

<ul>
<li>导航栏</li>
<li>个人介绍页面</li>
<li>分类Categories</li>
<li>sina微薄分享</li>
<li>评论</li>
</ul>


<p>好在octopress的可定制性非常强，其核心配置文件叫 `_config.yml,  基本上的配置都需要用到这个文件。它的逻辑比较简单，blog所有的配置都在这个文件，它的基本格式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Disqus Comments
</span><span class='line'>disqus_short_name: 
</span><span class='line'>disqus_show_comment_count:</span></code></pre></td></tr></table></div></figure>


<p>这是一个第三方的评论插件，通过简单的设置即可实现blog中加入评论。注意，该文件是基于yaml语法，：后面的空格不能省略。该文件还有许多其他的参数可以配置，其中本文主要关注的是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># list each of the sidebar modules you want to include, in the order you want them to appear.
</span><span class='line'># To add custom asides, create files in /source/_includes/custom/asides/ and add them to the list like 'custom/asides/custom_aside_name.html'
</span><span class='line'>default_asides: [asides/about.html, asides/weibo.html, asides/category_list.html, asides/recent_posts.html, asides/github.html, asides/twitter.html, asides/delicious.html, asides/pinboard.html, asides/googleplus.html]</span></code></pre></td></tr></table></div></figure>


<p>如注释中提到，asides的设置，关联的目录在<code>/source/\_includes/custom/asides</code>。比如想要在右侧边栏中加入about me框，则需要在<code>/source/\_includes/custom/asides/</code>中新建about.html。建议借用该目录下默认的about.html。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;section&gt;
</span><span class='line'>  &lt;h1&gt;About Me&lt;/h1&gt;
</span><span class='line'>  &lt;p&gt;A little something about me.&lt;/p&gt;
</span><span class='line'>&lt;/section&gt;</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h1>配置方法</h1>

<p>博主的自定义主要参考网络上的几篇blog，在这里不再详述，实现的功能有:</p>

<ul>
<li>octopress navigation设置</li>
<li>about页面，需要用rake new_page[&#8220;about&#8221;]，先生成页面。</li>
<li>octopress 侧边栏设置</li>
<li>个人介绍</li>
<li>sina微博分享</li>
<li>categories</li>
<li>google analysis</li>
</ul>


<h1>参考文献</h1>

<p><a href="http://yanping.me/cn/blog/2012/01/07/theming-and-customization/">ctopress修改主题和自定义样式</a></p>

<p><a href="http://linyi.herokuapp.com/blog/config-octopress.html">octopress的个性化配置</a></p>

<p><a href="http://codemacro.com/2012/07/18/add-category-list-to-octopress/">为octopress添加分类(category)列表</a></p>

<p><a href="http://programus.github.com/blog/2012/03/03/add-weibo-sidebar-into-octopress/">为Octopress博客追加新浪微博侧栏</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Orange's一个操作系统的实现---心得与体会]]></title>
    <link href="http://whbzju.github.com/blog/2013/02/23/tryos-xindetihui/"/>
    <updated>2013-02-23T15:57:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/02/23/tryos-xindetihui</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本科的时候，室友有一本《自己动手写操作系统》，曾拿来翻了一翻，觉得十分有趣，可惜当时要应付考研，没有时间好好看这本书。后来读研之后，马上入了一本，不过此时该书已经是第二版，叫《Orange&#8217;s 一个操作系统的实现》，却因自己畏难和拖延不决，一直到今天，马上要毕业了从把此书匆匆过了一遍。
不得不说，佩服作者的功力和心态，作者像是一个小孩，认真的为大家讲述他心爱的玩具是如何搭建的。在如今，实现一个这样的操作系统，并没有什么使用价值，只能作为学习的demo。为了搭建这个玩具，作者需要去了解x86架构的运行原理，内存的分页分段实现机制，8259A中断控制的部分原理和使用方法，还有文件系统、硬盘等等，我想当当是阅读这些设备组件的文档，就要耗去许多功夫，更别说调试的功夫。故在这种没有外界事物驱动的项目，若非有极大的热忱，是无论如何也坚持不下去。而我却连读完这本书这件事情都拖了3年，想来真是惭愧。</p>

<h1>内容概述</h1>

<p>整本书分为上下两篇，上篇的内容更为底层一些，因为本书是真正实现一个系统，所以上篇中有很多内容是有关硬件细节的，需要一定的汇编基础。下篇的内容则和我们平时接触的操作系统书籍有些类似，像IPC、文件系统、内存管理等更高级的话题，以C语言实现为主，也有部分汇编代码。内容大致分为：
* 环境搭建&#8212;bochs、linux
* cpu相关&#8212;引导扇区、保护模式
* 内核相关&#8212;内核雏形、进程、输入输出
* 进程通信IPC
* 文件系统&#8212;硬盘驱动和简单的文件系统
* 内存管理&#8212;fork、MM的简单实现
* 让OS能够部署到真正的机器中
本文变不打算重复书中的实现细节，因为文字没有代码讲的清楚，作者的代码带有大量的注释，所有的细节都在其中。</p>

<hr />

<!--more-->


<h2>环境搭建</h2>

<p>网上对bochs的环境配置有很多资料，作者使用的bochsrc在ubuntu下需要做些简单的修改。具体的配置过程也可以参照我的另一篇blog：<a href="http://whbzju.github.com/blog/2013/02/04/bochs-config/">Ubuntu 12.04安装bochs 2.3.5</a>.</p>

<h2>cpu相关</h2>

<p>第三章保护模式的内容是整本书的基础。后续章节讨论的内容都需要以此章的知识为基础。若你想深入了解操作系统实现的细节，本章是必须掌握的内容，当然如果你在本章遇到了困难，也可以先看后续章节，通过后续章节的知识来反馈本章的内容，也是一条可行之路，譬如博主就是这样做的。知识需要时间的沉淀，可能当时你很难理解的内容，过了一阵子，在其他知识的帮助下，你可以很顺利的理解它。然而，本章的内容你是无法糊弄过去，否则将会成为你理解是后续章节内容的傍脚石。
其中，保护模式的概念理解是一个坎，去网上了解下cpu发展的历史和相应的保护模式介绍内容将有助于你了解它。在理解概念后，书中所讲的只是如何通过汇编来使cpu进入保护模式而已，没有其他障碍。接着是整个操作系统运行原理的基石，分别为特权集的变化(特别是在变换时栈的变化)、中断的原理（8259A芯片的操作）和GDT、LDT、页式存储等一些重要的概念。</p>

<h2>内核相关</h2>

<p>在前面的章节中，我们写的程序是直接在引导程序中，而一个操作系统必然是要运行其他程序的，那么，自然要实现我们自己的内核。而一个操作系统从开机到运行。</p>

<blockquote><p>大致经历“引导&#8212;>加载内核入内存&#8212;>跳入保护模式&#8212;>开始执行内核”。</p></blockquote>

<p>这样看来引导区扇的512字节很可能不够，所以有必要实现一个loader来加载内核。第四章重点介绍了FAT12和loader的实现。第五章开始讲述内核的实现，其中一个重要的概念是ELF，类似于一种标准，告诉loader怎么加载程序。该章最后在内核中加入中断，这样一个内核雏形就完成了。第六章的讲述的是进程，操作系统中最重要的概念。在实现进程，除了我们已经了解的进程表的设置和进程调度算法外，本章提到的进程切换的特权集变换和栈空间的变换值得学习。当然，本章还实现了多线程，利用cpu时钟中断的机制实现。最后是系统调用，这里面涉及到讨论宏内核和微内核的内容，作者的选择是微内核。第七章是输入输出的内容，我兴趣不大，一带而过了。</p>

<h2>进程通信IPC</h2>

<p>本章节的内容没什么好说的，由于作者采用微内核，故在实现IPC时，需要有类似与MM的系统调用。</p>

<h2>文件系统</h2>

<p>一开始是对硬盘的介绍，目的是要实现一个硬盘的驱动程序。接着对文件系统的核心数据结构进行设计，见代码。</p>

<h2>内存管理</h2>

<p>内存管理本来是我十分感兴趣的一章，但是本书对该部分的内容算是浅尝而至，没有达到我对他的期望。不过，关于内存分配的细节还是能通过本章的例子了解不少。不过，本章的最后实现了一个简单的shell，算是一个补偿。</p>

<h2>尾声</h2>

<p>在书本的最后，作者将自己的操作系统安装到真正的机器中，作为本书的结尾。</p>

<h1>总结</h1>

<p>整本书读下来，虽然有不少知识点我不感兴趣，囫囵吞枣般的过去了，还是有不少收获。特别是对中断、栈空间、进程的理解有了进一步，下一步阅读有关操作系统方面经典的书籍应该会有不一样的体会，而且为我后面了解linux内核和android系统源码应该有不少帮助，这样我的目的也就达到了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ubuntu 12.04安装bochs 2.3.5]]></title>
    <link href="http://whbzju.github.com/blog/2013/02/04/bochs-config/"/>
    <updated>2013-02-04T23:37:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/02/04/bochs-config</id>
    <content type="html"><![CDATA[<p>一直对操作系统本身抱有一定的崇拜心理，可是长久以来都没有好好专研下这本书。趁着工作之前的最后一个寒假，希望能顺利完成这本书，对操作系统的认识有一个新的认识。</p>

<blockquote><p>工欲善其事，必先利其器
首先，我们先要配置出书本中模拟实验的环境，即虚拟机bochs的配置。众所周知，bochs的安装包版本是不带有调试功能的，只有通过编译bochs源码，才能启用debug模式。</p></blockquote>

<h2>bochs 2.3.5源码编译</h2>

<p>网上编译bochs的资料非常多，基本的问题都有解决方案，我重点讲不常见的问题。
<strong>基本安装步骤</strong></p>

<pre><code>tar vxzf bochs-2.3.5.tar.gz
cd bochs-2.3.5
sudo ./configure --enable-debugger --enable-disasm
sudo make
sudo make install
</code></pre>

<p>bochs是c++实现的，因此其依赖环境会有build-esstianl g++ devlib等，需事先安装环境</p>

<pre><code>sudo apt-get install build-essential
sudo apt-get install xorg-dev //GUI界面
sudo apt-get install bison
</code></pre>

<p>在执行./configure时，出现apt-get orgx-dev后依旧出现仍然提示<em>ERROR: X windows gui was selected, but X windows libraries were not found</em></p>

<!--more-->


<p>采用解决办法：</p>

<blockquote><p>只要编译的时候连接了 -lX11这个库就可以了，所以可以让configure阶段出错的地方不退出，并且在make的时候link X11这个库，编辑configure, 将退出的地方注释掉</p>

<pre><code>echo ERROR: X windows gui was selected, but X windows libraries were not found.
    #exit 1
</code></pre></blockquote>

<pre><code>configure命令后加 LDFLAGS="-L/usr/lib/i386-linux-gnu -lX该问题不能用--with-nogui解决，否则无法输出hello os，因为需要使用gui
</code></pre>

<p><strong>make</strong>之前需要修改一份文件bx_debug/symbol.cc</p>

<pre><code>在97行之后加入代码如下,
using namespace std;

#ifdef __GNUC__ //修改
using namespace __gnu_cxx; //修改
#endif //修改

struct symbol_entry_t
</code></pre>

<p>keymap若提示找不到，注释掉即可。</p>

<h2>bochsrc</h2>

<p>bochsrc是bochs启动时读取配置的文件，其中关键的是romimage和vgaromimage的路径设置。关于rom，install vagbios后，/usr/share/bochs路径存在，romimage路径在ubuntu下：/usr/local/share/bochs，修改下即可</p>

<h2>制作引导盘</h2>

<p>用bximage制作软盘映像
<code>bximage
按提示制作
将引导扇区写入软盘
</code>dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc</p>

<h2>启动bochs</h2>

<p>终端中输入bochs，按提示输入，在debug模式下，需要输入c让程序运行。若一切顺利，能看到屏幕上输出hello os的字符。</p>

<h2>关于64位机子的问题</h2>

<p>在configure时，enable-long-phy-address不存在，无法顺利支持64位寻址，需进一步研究确认。</p>

<h2>诡异问题</h2>

<p>依旧还有unknow VEG error，不知道怎么解决。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 12.04配置Octopress在Github上搭建blog]]></title>
    <link href="http://whbzju.github.com/blog/2013/02/02/octopress-peizhi/"/>
    <updated>2013-02-02T11:04:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/02/02/octopress-peizhi</id>
    <content type="html"><![CDATA[<p>  至从看到同学在Github上搭建的blog，深以为这才是我想要的blog，简洁漂亮，静态页面，离线编辑，markdown文档写作格式，git版本控制。所以当论文的事情告一段落，终于有时间来折腾它。起初，我在window平台上搭建，参考该<a href="http://shanewfx.github.com/blog/2012/02/16/bulid-blog-by-octopress/">文献</a>配置，其中最大的问题是中文字符支持的问题。</p>

<h2>内容概述</h2>

<ul>
<li>ubuntu 12.04配置octopress和github Page</li>
<li>git 配置问题，ssh key管理。</li>
<li>维护已经存在的github blog</li>
<li>vim的markdown语法高亮插件设置和所见即所得设置</li>
</ul>


<h2>ubuntu 12.04配置octopress和github Page</h2>

<p>  首先，我们来了解下概念问题，关于octopress，可以见下文：</p>

<blockquote><p>Octopress is a blogging framework which generates your enire blog in static files. Octopress has integrated Twitter, Google Analytics, Google Plus, Facebook and some other webservices. There are also good plugins for adding images, code, videos and other content into your blog posts. The framework is made for hackers and people who know something about Linux and shell.There are three official ways to deploy Octopress
Github Pages
Heroku
Rsync</p></blockquote>

<p>大致的意思是说octopress是一个静态页面生成框架，具有一些列集成的功能。有三种发布方式：Github Pages，Heroku和Rsync，本文采用Github Pages。由于Octopress是基于Ruby实现，我对ruby没有接触，从别人blog中了解到一下关于ruby的几个重要概念</p>

<blockquote><p>Gem ruby的easy install，用来安装各种库，是用ruby写的，全称叫rubygems。
Bundler 基于gem的更高级管理工具，bundler相对于gem就好比apt-get相对于aptitude。不过他不是单纯的下载安装，他会根据本目录的Gemfile文件，把你缺少的包给装上。
Rvm Ruby Version Manager，用来安装各种版本的ruby，问题是ubuntu有apt-get，这个不大派上用场。
Rbenv Simple Ruby Version Management，也是用来安装各种版本的ruby。
Rake Ruby Make，顾名思义就是ruby写的make，他对应的Makefile是Rakefile</p></blockquote>

<!--more-->


<h3>配置安装环境</h3>

<p>ubuntu在默认环境下是没有octorpess的依赖环境，同时也缺少git工具。所以首先：</p>

<pre><code>sudo apt-get install bash curl git-core -y
sudo apt-get install build-essential bison openssl libreadline6 libreadline6-dev zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev automake -y
</code></pre>

<p>接着安装rvm，我们采用rvm来安装ruby和octopress的依赖环境。
<code>bash -s stable &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer)</code>
同时我们还需要配置bash的环境，并重启bash</p>

<pre><code>echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; . "$HOME/.rvm/scripts/rvm" # Load RVM function' &gt;&gt; ~/.bashrc
source .bashrc
</code></pre>

<p>然后，配置octopress的环境：</p>

<pre><code>rvm pkg install openssl
rvm pkg install iconv
rvm install 1.9.2 -C --with-openssl-dir=$HOME/.rvm/usr,--with-iconv-dir=$HOME/.rvm/usr
rvm use 1.9.2 --default
rvm reload
rvm rubygems latest
gem install bundler
</code></pre>

<p>注意ubuntu 12.04默认的ruby版本是1.8.7，所以运行完上述命令务必要确认`ruby &#8211;version 来确认ruby的版本是否依旧修改成功。</p>

<h3>clone octopress</h3>

<pre><code>git clone git://github.com/imathis/octopress.git octopress

cd octopress/
</code></pre>

<h3>安装octopress</h3>

<p>安装octopress依赖环境</p>

<pre><code>gem install bundler
bundle install
</code></pre>

<p>安装octopress默认主题</p>

<pre><code>rake install
</code></pre>

<h3>部署到Github</h3>

<p>部署过程比较简单，每一步都有详细的提示。首先你得现在github上创建一个repository，且必须命名成username.github.com.git，其中username是你的github的用户名，参见<a href="http://beiyuu.com/github-pages/">用Github Pages搭建blog设置</a>。要注意的是ssh的管理，直接在github账户上添加ssh密钥，该密钥是作为deploy密钥，因此不能用于其他项目，也就是说，如果此时你有其他项目需要ssh密钥，该密钥已经不能被使用，你必须通过ssh-keygen重新生成密钥，并且通过ssh-agent进行切换。</p>

<p>用octopress写blog主要的步骤如下：</p>

<pre><code>rake new_post["title"]
rake generate
</code></pre>

<p>这样静态页面就生成好了，可以通过<code>rake preview</code>来预览，访问<code>localhost:4000</code>进行测试。</p>

<p>没有问题就可以通过<code>rake deploy</code>部署到github上。</p>

<p>同时，不要忘了将source分支也上传到github上，依照默认的octopress配置，它是将source和master分开，在source分支下完成文章编写，通过deploy到master中，默认情况下github上只有master分支。但是如果你有多台电脑，需要维护一个github blog，其他电脑必须checkout 该项目的source分支才能进行修改，否则会出错。因此，必须将source分支也加入到项目目录中</p>

<pre><code>git add .
git commit -m "origin source branch"
git push origin source
</code></pre>

<p>如果一切正常，过一会你就可以通过`username.github.com来访问你的blog。</p>

<h3>octopress主题安装</h3>

<p>我个人觉得默认主题不错，各位也可以安装其他主题，google吧。</p>

<h2>维护一个已经存在的github blog</h2>

<p>首先，在机子上配置ruby环境，rvm，git和octopress的环境。</p>

<p>接着从github上clone你的blog项目，比如：</p>

<pre><code>git clone git@github.com:username/username.github.com.git
</code></pre>

<p>checkout source分支，这个是必须的步骤</p>

<pre><code>cd username.github.com
git checkout source
</code></pre>

<p>重新配置本地octopress和Github Page的关联</p>

<pre><code>rake setup_github_pages
</code></pre>

<p>按提示完成设置</p>

<p>接着便于初次配置octopress一样的方式进行blog编写修改等。</p>

<h2>markdown编辑器的配置：VIM</h2>

<p>   在linux平台上，vim是我首选的编辑器，不想换其他专门针对markdown语法的编辑器。在写blog的时候，我希望编辑器能够有两个功能:</p>

<ul>
<li>支持markdown语法高亮</li>
<li>支持所见即所得模式编辑</li>
</ul>


<p>google了下发现，可以通过安装vim-octopress和vim-instant-markdown插件来实现。</p>

<h3>vim-octopress配置</h3>

<p>   建议采用<a href="https://github.com/tpope/vim-pathogen">Pathogen</a>来安装vim插件。</p>

<pre><code>cd ~/.vim/bundle
git clone https://github.com/tangledhelix/vim-octopress.git octopress
</code></pre>

<p>  若是没有设置过vim，先新建<code>~/.vimrc</code>和 <code>~/.vim/</code> 。最后在<code>.vimrc</code> 中加入，指定markdown的配色为octopress</p>

<pre><code>autocmd BufNewFile,BufRead *.markdown setfiletype octopress
</code></pre>

<h3>vim-instant-markdown插件配置</h3>

<p>  该插件的功能是让你在撰写markdown文档时能立即看到成文效果，在安装完毕后，使用vim时自动启动浏览器，实时的展现你撰写的内容。安装步骤见项目的github<a href="https://github.com/suan/vim-instant-markdown">主页</a>。我在安装该插件的时候遇到一些问题，还在解决中，希望能尽快使用它。</p>

<h2>总结&amp;展望</h2>

<p>  在折腾这个blog，分别在windows上和linux上都安装成功过，window上的中文字符集解决方法比较麻烦。linux下只要将语言设置到.bashrc即可。整个过程遇到多个ssh key管理问题，最后在github的help上找到ssh agent切换管理解决方案。ruby version不对，原因是ubuntu默认ruby版本为1.8.7，需要设置。在修改octopress中的其他文件，在git push时，需要用git add/rm 来处理这些文件后push。Github在build pages失败时，会有邮件提示错误原因，需要仔细看。
  总之，遇到问题先思考，有了思路后再针对性的查阅资料，尝试解决方案。</p>

<h3>接下来要解决的：</h3>

<ul>
<li>评论机制</li>
<li>代码高亮</li>
<li>主题修改</li>
<li>配置修改，config.yml文件等</li>
</ul>


<h2>参考</h2>

<p><a href="http://www.lennu.net/2012/05/11/octopress-installation-in-ubuntu-12-dot-04-with-rsync/">Octopress installation in Ubuntu 12.04 with rsync - Lennu.net</a></p>

<p><a href="http://xingfuqiu.com/blog/ubuntu-update-to-1204/">为已存在的Octopress配置环境</a></p>

<p>http://fancyoung.com/blog/octopress-study/</p>

<p>http://netwjx.github.com/blog/2012/03/18/octopress-note/</p>

<p>http://BeiYuu.com</p>

<p><a href="http://www.csser.com/board/4f53875c55bdcb545c000d05">配置 Git 和 SSH 密钥连接 Github - CSSer</a></p>

<p><a href="http://www.cnblogs.com/cheche/archive/2011/01/07/1918825.html">解决cygwin下的“Could not open a connection to your authentication agent.”</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[codeHighlight]]></title>
    <link href="http://whbzju.github.com/blog/2013/01/30/codehighlight/"/>
    <updated>2013-01-30T15:47:00+08:00</updated>
    <id>http://whbzju.github.com/blog/2013/01/30/codehighlight</id>
    <content type="html"><![CDATA[<h1>代码高亮</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$sudo give me a hug for test
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>test</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello world&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>Discover if a number is prime</span><a href='http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/'>Source Article</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="k">class</span> <span class="nc">Fixnum</span>
</span><span class='line'>   <span class="k">def</span> <span class="nf">prime?</span>
</span><span class='line'>     <span class="p">(</span><span class="s1">&#39;1&#39;</span> <span class="o">*</span> <span class="nb">self</span><span class="p">)</span> <span class="o">!~</span> <span class="sr">/^1?$|^(11+?)\1+$/</span>
</span><span class='line'>   <span class="k">end</span>
</span><span class='line'> <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Code Block</h2>

<figure class='code'><figcaption><span>testTitle  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello octopress&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>Javascript Array Syntax </span><a href='http://j.mp/pPUUmW'>MDN Documentation </a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">arrayLength</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">element0</span><span class="p">,</span> <span class="nx">element1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">elementN</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
</feed>
